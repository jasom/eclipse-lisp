/* Generated by Eclipse Common Lisp 1.1-HOSTED on cad0.
   Tuesday the twenty-sixth of May, 1998, 3:08:43 pm CDT. */
#include <eclipse.h>

clObject clSubtIntegerInteger(clObject,clObject), clLtIntegerInteger(clObject,clObject);
clObject cl1MINUS_FUNC(clProto),
  clAddIntegerInteger __P((clObject, clObject)),
  clAdjustedLambdaBindings(clProto), clAppend(clProto),
  clApply(clProto), clApplyFunction(clProto),
  clBindingformInitform(clProto), clBindingformName(clProto),
  clCallMethodMacrolet(clProto), clCanonicalizeClass(clProto),
  clCar(clProto), clCarEq(clProto), clCddr(clProto), clCdr(clProto),
  clCharpSimpleBaseString __P((clCharp)),
  clCheckCongruentLambda(clProto), clCheckKeys(clProto),
  clCheckSlotInitializationP(clProto), clClassOf(clProto),
  clClassp(clProto), clComputeEffectiveMethodFunction(clProto),
  clComputeMethodFunction(clProto),
  clComputeStandardEffectiveMethodFunction(clProto), clCons(clProto),
  clConsp(clProto), clEmfTableGet __P((clObject, clObject, clObject)),
  clEmfTableSet __P((clObject, clObject, clObject, clObject)),
  clEndp(clProto), clEq(clProto), clEql(clProto),
  clEqlSpecializerObject(clProto), clEqlSpecializerP(clProto),
  clError(clProto), clExtraArgs(clProto), clExtractKeywords(clProto),
  clFastFind __P((clObject, clObject)),
  clFastFindSlot __P((clObject, clObject)), clFind(clProto),
  clFindBadKey(clProto), clFindType(clProto), clFirst(clProto),
  clGenericFunctionAMPERSANDRestIndex(clProto), clGensym(clProto),
  cl_SETF_GlobalDeclaration(clProto), clIllegalChangeClass(clProto),
  clInvalidMethodError(clProto), clKeyNotAllowed(clProto),
  clLambdaAMPERSANDRestIndex(clProto), clLambdaListKeywordP(clProto),
  clLength(clProto), clList(clProto), clListSTAR(clProto),
  clListEq(clProto), clListp(clProto), clLocalSlotP(clProto),
  cl_SETF_MacroFunction(clProto), clMakeEffectiveMethodLambda(clProto),
  clMakeInternalMethod(clProto), clMakeKeyword(clProto),
  clMakeMethodExpansion(clProto), clMakeSlots __P((clObject)),
  clMethodCombinationError(clProto), clMinusp(clProto),
  clMissingArgs(clProto), clNInstanceSlots(clProto), clNconc(clProto),
  clNot(clProto), clNreverseList(clProto), clNth(clProto),
  clNthcdr(clProto), clNull(clProto), clPlusp(clProto),
  clPosition(clProto), clQuicksortList(clProto), clRest(clProto),
  clRplacd(clProto), clSecond(clProto), clSetExclusiveOr(clProto),
  clSetFuncallableInstanceFunction(clProto),
  clSignalProgramError(clProto), clSlotBoundp(clProto),
  clStandardInstanceAccess(clProto), clStaticClassWrapper(clProto),
  clStdMethodMoreSpecificP(clProto), clSubclassp(clProto),
  clSymbolName(clProto), clSymbolp(clProto), clThird(clProto),
  clUnion(clProto), clUpdateInstance(clProto), clValues(clProto);

extern clObject clampersandALLOW_OTHER_KEYS, clampersandAUX,
  clampersandKEY, clampersandOPTIONAL, clampersandREST,
  clampersandWHOLE, clDECLARE, clDYNAMIC_EXTENT, clIF, clIGNORE,
  clLAMBDA, clLETstar, clMACROLET, clQUOTE, clSETQ, clSPECIAL,
  clstarEQL_SPECIALIZER_TYPEstar, clstarGENERIC_FUNCTIONstar,
  clstarMETHOD_COMBINATIONstar, clstarSTANDARD_METHOD_COMBINATIONstar,
  clACCESSOR_METHOD_SLOT_DEFINITION, clADD, clADJUSTED_LAMBDA_BINDINGS,
  clALLOW_OTHER_KEYS_P, clAPPLY_METHOD, clARGS,
  clARGUMENT_PRECEDENCE_ORDER, clCALL_METHOD, clCALL_METHOD_EXPANSION,
  clCALL_METHOD_MACROLET, clCAR, clCHECK_INITARGS_1, clCHECK_KEYS,
  clCHECK_METACLASS, clCHECK_SLOT_INITIALIZATION_P, clCLASS_NAME,
  clCLASS_PRECEDENCE_LIST, clCLASS_SLOTS, clCLASS_WRAPPER,
  clCLASS_WRAPPERS, clCLASSP, clCOMPILE_OBJECT,
  clCOMPUTE_APPLICABLE_METHODS,
  clCOMPUTE_APPLICABLE_METHODS_USING_CLASSES,
  clCOMPUTE_DISCRIMINATING_FUNCTION, clCOMPUTE_EFFECTIVE_METHOD,
  clCOMPUTE_EFFECTIVE_METHOD_FUNCTION, clCOMPUTE_METHOD_FUNCTION,
  clCOMPUTE_STANDARD_EFFECTIVE_METHOD_FUNCTION, clD,
  clEQL_SPECIALIZER_OBJECT, clEQL_SPECIALIZER_P,
  clFINALIZE_GENERIC_FUNCTION, clFIND_SLOT_DEFINITION,
  clFLUSH_METHOD_CACHE, clFUNCALL_FUNCTION, clFUNCTION,
  clFUNCTION_KEYWORDS, clGENERIC_FUNCTION_ampersandREST_INDEX,
  clGENERIC_FUNCTION_ALLOW_OTHER_KEYS_P,
  clGENERIC_FUNCTION_ARGUMENT_PRECEDENCE_ORDER,
  clGENERIC_FUNCTION_KEYWORDS, clGENERIC_FUNCTION_LAMBDA_LIST,
  clGENERIC_FUNCTION_METHOD_COMBINATION, clGENERIC_FUNCTION_METHODS,
  clGENERIC_FUNCTION_NAME, clGENERIC_FUNCTION_REQUIRED_PARAMETERS,
  clGLOBAL_VARIABLE, clILLEGAL_CHANGE_CLASS, clILLEGAL_INITIALIZATION,
  clINITIALIZE_SLOT_P, clINVALID_METHOD_ERROR, clKEYWORDS,
  clLAMBDA_ampersandREST_INDEX, clLAMBDA_LIST, clLIST, clLOCAL_SLOT_P,
  clLT, clM, clMAKE_EFFECTIVE_METHOD_LAMBDA, clMAKE_INSTANCE,
  clMAKE_INTERNAL_METHOD, clMAKE_METHOD, clMAKE_METHOD_EXPANSION,
  clMEMBER, clMETHOD_COMBINATION_ERROR, clMETHOD_FUNCTION,
  clMETHOD_QUALIFIERS, clMETHOD_SPECIALIZERS, clMETHODS,
  clMISSING_ARGS, clN_INSTANCE_SLOTS, clNO_APPLICABLE_METHOD, clNTHCDR,
  clOBJECT, clOTHER_DATA, clPOP, clPROPER_NAME, clREQUIRED_PARAMETERS,
  clSET_GF_LAMBDA_LIST, clSETF, clSLOT_BOUNDP,
  clSLOT_BOUNDP_USING_CLASS, clSLOT_DEFINITION_ALLOCATION,
  clSLOT_DEFINITION_LOCATION, clSLOT_DEFINITION_NAME, clSLOT_EXISTS_P,
  clSLOT_MAKUNBOUND, clSLOT_MAKUNBOUND_USING_CLASS, clSLOT_MISSING,
  clSLOT_VALUE, clSLOT_VALUE_USING_CLASS, clSORT_APPLICABLE_METHODS,
  clSPECIALIZERP, clSTANDARD_DISCRIMINATING_FUNCTION,
  clSTANDARD_GENERIC_FUNCTION_CLASSOBJ, clSTANDARD_METHOD_CLASSOBJ,
  clSTANDARD_READER_METHOD_CLASSOBJ,
  clSTANDARD_SYSTEM_GENERIC_FUNCTION_CLASSOBJ,
  clSTANDARD_WRITER_METHOD_CLASSOBJ, clSTATIC_CLASS_WRAPPER,
  clSTD_METHOD_MORE_SPECIFIC_P, clSUBCLASSP, clSUBT, clUPDATE_INSTANCE,
  clUPDATE_INSTANCE_FOR_REDEFINED_CLASS, clUPDATE_INSTANCES_IF_NEEDED;

static clObject CONS_0, CONS_1, CONS_10, CONS_11, CONS_12, CONS_13,
  CONS_14, CONS_15, CONS_16, CONS_17, CONS_2, CONS_3, CONS_4, CONS_5,
  CONS_6, CONS_7, CONS_8, CONS_9, I_0, I_1, I_16, I_2, I_3, I_4, I_6,
  keyAFTER, keyARGUMENTS, keyAROUND, keyBEFORE, keyFUNCTION,
  keyGENERIC_FUNCTION, keyINSTANCE, keyKEY, STR_AFTER__11,
  STR_ARGS__16, STR_ARGUMENTS__14, STR_AROUND__9, STR_BEFORE__10,
  STR_Cannot_tildea_tildesdot__0, STR_FUNCTION__8,
  STR_GENERIC_FUNCTION__15, STR_INSTANCE__4, STR_KEY__6, STR_REST__17,
  STR_for_class_tildes__18,
  STR_tildequestiontilde___tildewcolon_tildewdot__2, STRn_1, STRn_12,
  STRn_13, STRn_3, STRn_5, STRn_7;

clObject clIllegalInitialization clVdecl(_ap)
{ clObject op, CL_class;
  { clBeginParse(_ap);
    clSetq(op, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_2, L_1;
    clSetq(L_1, op);
    clSetq(L_2, CL_class);
    return(clError(STR_Cannot_tildea_tildesdot__0, L_1, L_2,
                   clEOA)); } }

clObject clIllegalChangeClass clVdecl(_ap)
{ clObject instance, new_class;
  { clBeginParse(_ap);
    clSetq(instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(new_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_3, L_2, L_1;
    clSetq(L_1, instance);
    { clObject L_0__R1;
      clSetq(L_0__R1, instance);
      clSetq(L_2, clClassOf(L_0__R1, clEOA)); }
    clSetq(L_3, new_class);
    return(clError(STRn_1, L_1, L_2, L_3, clEOA)); } }

clObject clCheckMetaclass clVdecl(_ap)
{ clObject CL_class, metaclass;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(metaclass,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject old_metaclass, new_metaclass;
    { clObject L_0;
      clSetq(L_0, CL_class);
      clSetq(old_metaclass, clClassOf(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, metaclass);
      clSetq(new_metaclass, clCanonicalizeClass(L_0, clT, clEOA)); }
    if (clTrue(clNot(clEq(old_metaclass, new_metaclass, clEOA),
                     clEOA)))
      { clObject L_0;
        clSetq(L_0, CL_class);
        return(clIllegalChangeClass(L_0, new_metaclass, clEOA)); }
    else return(clValues1(clNIL)); } }

clObject clMethodCombinationError clVdecl(_ap)
{ clObject format_string, args;
  { clBeginParse(_ap);
    clSetq(format_string,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(args, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_3, L_1;
    clSetq(L_1, format_string);
    clSetq(L_3, clSymbolValue(clstarGENERIC_FUNCTIONstar, clEOA));
    return(clError(STR_tildequestiontilde___tildewcolon_tildewdot__2,
                   L_1, args, L_3,
                   clSymbolValue(clstarMETHOD_COMBINATIONstar, clEOA),
                   clEOA)); } }

clObject clInvalidMethodError clVdecl(_ap)
{ clObject method, format_string, args;
  { clBeginParse(_ap);
    clSetq(method,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(format_string,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(args, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_3, L_2, L_0;
    clSetq(L_0, clSymbolFunctionValue(clMETHOD_COMBINATION_ERROR));
    clSetq(L_2, method);
    clSetq(L_3, format_string);
    return(clApply(L_0, STRn_3, L_2, L_3, args, clEOA)); } }

clObject clLocalSlotP clVdecl(_ap)
{ clObject slot;
  { clBeginParse(_ap);
    clSetq(slot,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, slot);
      clSetq(L_0,
             clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_ALLOCATION),
                               L_0__R1,
                               clEOA)); }
    return(clEq(L_0, keyINSTANCE, clEOA)); } }

clObject clSubclassp clVdecl(_ap)
{ clObject c1, c2;
  { clBeginParse(_ap);
    clSetq(c1, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(c2, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_1, L_0;
      clSetq(L_0, c1);
      clSetq(L_1, c2);
      clSetq(L_test, clEq(L_0, L_1, clEOA)); }
    if (clTrue(L_test))
      return(clValues1(clT));
    else
      { clObject L_1, L_0;
        clSetq(L_0, c2);
        { clObject L_0__R1;
          clSetq(L_0__R1, c1);
          clSetq(L_1, clStandardInstanceAccess(L_0__R1, I_6, clEOA)); }
        return(clValues1(clFastFind(L_0, L_1))); } } }

clObject clClassp clVdecl(_ap)
{ clObject object, CL_class;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, object);
      clSetq(L_0, clClassOf(L_0__R1, clEOA)); }
    clSetq(L_1, CL_class);
    return(clSubclassp(L_0, L_1, clEOA)); } }

clObject clEqlSpecializerP clVdecl(_ap)
{ clObject object;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, object);
    return(clClassp(L_0,
                    clSymbolValue(clstarEQL_SPECIALIZER_TYPEstar,
                                  clEOA),
                    clEOA)); } }

clObject clSpecializerp clVdecl(_ap)
{ clObject object, specializer;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(specializer,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_0;
      clSetq(L_0, specializer);
      clSetq(L_test, clEqlSpecializerP(L_0, clEOA)); }
    if (clTrue(L_test))
      { clObject L_1, L_0;
        clSetq(L_0, object);
        { clObject L_0__R1;
          clSetq(L_0__R1, specializer);
          clSetq(L_1, clEqlSpecializerObject(L_0__R1, clEOA)); }
        return(clEql(L_0, L_1, clEOA)); }
    else
      { clObject L_1, L_0;
        clSetq(L_0, object);
        clSetq(L_1, specializer);
        return(clClassp(L_0, L_1, clEOA)); } } }

clObject clStdMethodMoreSpecificP clVdecl(_ap)
{ clObject gf, method1, method2, required_classes;
  { clBeginParse(_ap);
    clSetq(gf, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(method1,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(method2,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(required_classes,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject args, order, specs1, specs2;
    { clObject L_0;
      clSetq(L_0, gf);
      clSetq(args,
             clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_REQUIRED_PARAMETERS),
                               L_0,
                               clEOA)); }
    { clObject L_0;
      clSetq(L_0, gf);
      clSetq(order,
             clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_ARGUMENT_PRECEDENCE_ORDER),
                               L_0,
                               clEOA)); }
    { clObject L_0;
      clSetq(L_0, method1);
      clSetq(specs1,
             clFuncallFunction(clSymbolFunctionValue(clMETHOD_SPECIALIZERS),
                               L_0,
                               clEOA)); }
    { clObject L_0;
      clSetq(L_0, method2);
      clSetq(specs2,
             clFuncallFunction(clSymbolFunctionValue(clMETHOD_SPECIALIZERS),
                               L_0,
                               clEOA)); }
    if (clTrue(clListEq(args, order, clEOA)))
      { clObject spec1, L_g0, spec2, L_g1, CL_class, L_g2;
        clSetq(spec1, clNIL);
        clSetq(L_g0, specs1);
        clSetq(spec2, clNIL);
        clSetq(L_g1, specs2);
        clSetq(CL_class, clNIL);
        clSetq(L_g2, required_classes);
        clLabel(NEXT_LOOP);
        { clObject L_test__R1;
          { clObject L_g407;
            clSetq(L_g407, clEndp(L_g0, clEOA));
            if (clTrue(L_g407))
              clSetq(L_test__R1, L_g407);
            else
              { clObject L_g408;
                clSetq(L_g408, clEndp(L_g1, clEOA));
                clSetq(L_test__R1,
                       (clTrue(L_g408) ?
                        L_g408 :
                        clEndp(L_g2, clEOA))); } }
          if (clTrue(L_test__R1)) goto END_LOOP; }
        { clObject L_first_val409;
          clSetq(L_first_val409, clCar(L_g0, clEOA));
          { clObject L_first_val410;
            clSetq(L_first_val410, clCar(L_g1, clEOA));
            clSetq(CL_class, clCar(L_g2, clEOA));
            clSetq(spec2, L_first_val410); }
          clSetq(spec1, L_first_val409); }
        { clObject L_0;
          clSetq(L_0, L_g0);
          clSetq(L_g0, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_g1);
          clSetq(L_g1, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_g2);
          clSetq(L_g2, clCdr(L_0, clEOA)); }
        { clObject L_test__R1;
          { clObject L_0;
            { clObject L_1, L_0__R1;
              clSetq(L_0__R1, spec1);
              clSetq(L_1, spec2);
              clSetq(L_0, clEq(L_0__R1, L_1, clEOA)); }
            clSetq(L_test__R1, clNot(L_0, clEOA)); }
          if (clTrue(L_test__R1))
            { clObject L_test__R2;
              { clObject L_0;
                clSetq(L_0, spec1);
                clSetq(L_test__R2, clEqlSpecializerP(L_0, clEOA)); }
              if (clTrue(L_test__R2))
                return(clValues1(clT));
              else
                { clObject L_test__R3;
                  { clObject L_0;
                    clSetq(L_0, spec2);
                    clSetq(L_test__R3,
                           clEqlSpecializerP(L_0, clEOA)); }
                  if (clTrue(L_test__R3))
                    return(clValues1(clNIL));
                  else
                    { clObject cpl;
                      { clObject L_0;
                        clSetq(L_0, CL_class);
                        clSetq(cpl,
                               clFuncallFunction(clSymbolFunctionValue(clCLASS_PRECEDENCE_LIST),
                                                 L_0,
                                                 clEOA)); }
                      { clObject L_1, L_0;
                        clSetq(L_0, spec2);
                        { clObject L_0__R1;
                          { clObject L_item412, L_sub411;
                            clSetq(L_item412, spec1);
                            clSetq(L_sub411, cpl);
                            clLabel(l_ITERATE414);
                            if (clTrue(clEndp(L_sub411, clEOA)))
                            { clSetq(L_0__R1, clNIL);
                              clLocalReturn(NIL__r1); }
                            if (clTrue(clEql(L_item412,
                                             clCar(L_sub411, clEOA),
                                             clEOA)))
                            { clSetq(L_0__R1, L_sub411);
                              clLocalReturn(l_MEMBER413__r1); }
                            { clObject L_value415;
                              clSetq(L_value415,
                                     clCdr(L_sub411, clEOA));
                              clSetq(L_sub411, L_value415); }
                            goto l_ITERATE414; }
                          clBlockEnd(NIL__r1);
                          clBlockEnd(l_MEMBER413__r1);
                          clSetq(L_1, clCdr(L_0__R1, clEOA)); }
                        return(clValues1(clFastFind(L_0,
                                                    L_1))); } } } } }
        goto NEXT_LOOP;
        clLabel(END_LOOP);
        return(clValues1(clNIL));
        return(clValues1(clNIL)); }
    else
      { clObject L_sublist416, name;
        clSetq(L_sublist416, order);
        clSetq(name, clCar(L_sublist416, clEOA));
        clLabel(l_ITERATE417);
        if (clTrue(clEndp(L_sublist416, clEOA)))
          return(clValues1(clNIL));
        { clObject position, spec1, spec2;
          clSetq(position, clPosition(name, args, clEOA));
          clSetq(spec1, clNth(position, specs1, clEOA));
          clSetq(spec2, clNth(position, specs2, clEOA));
          if (clTrue(clNot(clEq(spec1, spec2, clEOA), clEOA)))
            if (clTrue(clEqlSpecializerP(spec1, clEOA)))
              return(clValues1(clT));
            else if (clTrue(clEqlSpecializerP(spec2, clEOA)))
              return(clValues1(clNIL));
            else
              { clObject cpl;
                { clObject L_0;
                  { clObject L_1;
                    clSetq(L_1, required_classes);
                    clSetq(L_0, clNth(position, L_1, clEOA)); }
                  clSetq(cpl,
                         clFuncallFunction(clSymbolFunctionValue(clCLASS_PRECEDENCE_LIST),
                                           L_0,
                                           clEOA)); }
                { clObject L_1;
                  { clObject L_0__R1;
                    { clObject L_sub418;
                      clSetq(L_sub418, cpl);
                      clLabel(l_ITERATE421);
                      if (clTrue(clEndp(L_sub418, clEOA)))
                      { clSetq(L_0__R1, clNIL);
                        clLocalReturn(NIL__r2); }
                      if (clTrue(clEql(spec1,
                                       clCar(L_sub418, clEOA),
                                       clEOA)))
                      { clSetq(L_0__R1, L_sub418);
                        clLocalReturn(l_MEMBER420__r2); }
                      { clObject L_value422;
                        clSetq(L_value422, clCdr(L_sub418, clEOA));
                        clSetq(L_sub418, L_value422); }
                      goto l_ITERATE421; }
                    clBlockEnd(NIL__r2);
                    clBlockEnd(l_MEMBER420__r2);
                    clSetq(L_1, clCdr(L_0__R1, clEOA)); }
                  return(clValues1(clFastFind(spec2, L_1))); } } }
        { clObject L_0;
          clSetq(L_0, L_sublist416);
          clSetq(L_sublist416, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_sublist416);
          clSetq(name, clCar(L_0, clEOA)); }
        goto l_ITERATE417; } } }

clObject clCheckSlotInitializationP clVdecl(_ap)
{ clObject slot_name, slot_names;
  { clBeginParse(_ap);
    clSetq(slot_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(slot_names,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_g423;
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, slot_names);
        clSetq(L_0, clListp(L_0__R1, clEOA)); }
      clSetq(L_g423, clNot(L_0, clEOA)); }
    if (clTrue(L_g423))
      return(clValues1(L_g423));
    else
      { clObject L_item425, L_sub424;
        clSetq(L_item425, slot_name);
        clSetq(L_sub424, slot_names);
        clLabel(l_ITERATE427);
        if (clTrue(clEndp(L_sub424, clEOA))) return(clValues1(clNIL));
        if (_clEq(L_item425, clCar(L_sub424, clEOA)))
          return(clValues1(L_sub424));
        { clObject L_value428;
          clSetq(L_value428, clCdr(L_sub424, clEOA));
          clSetq(L_sub424, L_value428); }
        goto l_ITERATE427; } } }

clObject clInitializeSlotP clVdecl(_ap)
{ clObject instance, slot_name, slot_names;
  { clBeginParse(_ap);
    clSetq(instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(slot_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(slot_names,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_1, L_0;
      clSetq(L_0, slot_name);
      clSetq(L_1, slot_names);
      clSetq(L_test, clCheckSlotInitializationP(L_0, L_1, clEOA)); }
    if (clTrue(L_test))
      { clObject L_0;
        { clObject L_1, L_0__R1;
          clSetq(L_0__R1, instance);
          clSetq(L_1, slot_name);
          clSetq(L_0, clSlotBoundp(L_0__R1, L_1, clEOA)); }
        return(clNot(L_0, clEOA)); }
    else return(clValues1(clNIL)); } }

clObject clProperName clVdecl(_ap)
{ clObject CL_class, errorp, environment;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(errorp, (_clVp(_ap) ? clVpop(_ap) : clT));
    clSetq(environment, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject name;
    { clObject L_0;
      clSetq(L_0, CL_class);
      clSetq(name,
             clFuncallFunction(clSymbolFunctionValue(clCLASS_NAME),
                               L_0,
                               clEOA)); }
    { clObject L_test;
      if (clTrue(name))
        if (clTrue(clSymbolp(name, clEOA)))
          { clObject L_1, L_0;
            clSetq(L_0, CL_class);
            { clObject L_2;
              clSetq(L_2, environment);
              clSetq(L_1, clFindType(name, clNIL, L_2, clEOA)); }
            clSetq(L_test, clEq(L_0, L_1, clEOA)); }
        else clSetq(L_test, clNIL);
      else clSetq(L_test, clNIL);
      if (clTrue(L_test))
        return(clValues1(name));
      else if (clTrue(errorp))
        { clObject L_1;
          clSetq(L_1, CL_class);
          return(clError(STRn_5, L_1, clEOA)); }
      else return(clValues1(clNIL)); } } }

clObject clNInstanceSlots clVdecl(_ap)
{ clObject slot_definitions;
  { clBeginParse(_ap);
    clSetq(slot_definitions,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject n;
    clSetq(n, I_0);
    { clObject slot, L_g3;
      clSetq(slot, clNIL);
      clSetq(L_g3, slot_definitions);
      clLabel(NEXT_LOOP);
      if (clTrue(clEndp(L_g3, clEOA))) goto END_LOOP;
      clSetq(slot, clCar(L_g3, clEOA));
      { clObject L_0;
        clSetq(L_0, L_g3);
        clSetq(L_g3, clCdr(L_0, clEOA)); }
      { clObject L_test;
        { clObject L_0;
          clSetq(L_0, slot);
          clSetq(L_test, clLocalSlotP(L_0, clEOA)); }
        if (clTrue(L_test))
          { clObject L_0;
            clSetq(L_0, n);
            clSetq(n, clAddIntegerInteger(L_0, I_1)); } }
      goto NEXT_LOOP;
      clLabel(END_LOOP);
      return(clValues1(n));
      return(clValues1(clNIL)); } } }

clObject clLambdaAMPERSANDRestIndex clVdecl(_ap)
{ clObject lambda_list;
  { clBeginParse(_ap);
    clSetq(lambda_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject parameter, L_g4;
    clSetq(parameter, clNIL);
    clSetq(L_g4, lambda_list);
    { clObject index;
      clSetq(index, I_0);
      clLabel(NEXT_LOOP);
      if (clTrue(clEndp(L_g4, clEOA))) goto END_LOOP;
      clSetq(parameter, clCar(L_g4, clEOA));
      { clObject L_0;
        clSetq(L_0, L_g4);
        clSetq(L_g4, clCdr(L_0, clEOA)); }
      { clObject L_key429;
        clSetq(L_key429, parameter);
        if (clTrue((_clEq(L_key429, clampersandREST) ? CONS_0 :
                    (_clEq(L_key429, clampersandKEY) ? CONS_1 :
                     clNIL))))
          return(clValues1(index));
        else if (!_clEq(L_key429, clampersandOPTIONAL))
          if (_clEq(L_key429, clampersandAUX))
            return(clValues1(index));
          else
            { clObject L_0;
              clSetq(L_0, index);
              clSetq(index,
                     clFuncallFunction(clSymbolFunctionValue(clADD),
                                       L_0,
                                       I_1,
                                       clEOA)); } }
      goto NEXT_LOOP;
      clLabel(END_LOOP);
      return(clValues1(index));
      return(clValues1(clNIL)); } } }

clObject clGenericFunctionAMPERSANDRestIndex clVdecl(_ap)
{ clObject gf;
  { clBeginParse(_ap);
    clSetq(gf, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, gf);
      clSetq(L_0,
             clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_LAMBDA_LIST),
                               L_0__R1,
                               clEOA)); }
    return(clLambdaAMPERSANDRestIndex(L_0, clEOA)); } }

clObject clEqlSpecializerObject clVdecl(_ap)
{ clObject eql_specializer;
  { clBeginParse(_ap);
    clSetq(eql_specializer,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_instance431, L_class432, L_object433;
    clSetq(L_instance431, eql_specializer);
    clSetq(L_class432, clClassOf(L_instance431, clEOA));
    clSetq(L_object433, clFastFindSlot(L_class432, clOBJECT));
    return(clFuncallFunction(clSymbolFunctionValue(clSLOT_VALUE_USING_CLASS),
                             L_class432,
                             L_instance431,
                             L_object433,
                             clEOA)); } }

clObject clStaticClassWrapper clVdecl(_ap)
{ clObject CL_class;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, CL_class);
    return(clStandardInstanceAccess(L_0, I_16, clEOA)); } }

clObject clClassWrappers clVdecl(_ap)
{ clObject class_list;
  { clBeginParse(_ap);
    clSetq(class_list,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject CL_class, L_g5;
    clSetq(CL_class, clNIL);
    clSetq(L_g5, class_list);
    { clObject L_g6, L_g7;
      clSetq(L_g6, clList(clNIL, clEOA));
      clSetq(L_g7, L_g6);
      clLabel(NEXT_LOOP);
      if (clTrue(clEndp(L_g5, clEOA))) goto END_LOOP;
      clSetq(CL_class, clCar(L_g5, clEOA));
      { clObject L_0;
        clSetq(L_0, L_g5);
        clSetq(L_g5, clCdr(L_0, clEOA)); }
      { clObject L_1, L_0;
        clSetq(L_0, L_g7);
        { clObject L_0__R1;
          { clObject L_0__R2;
            clSetq(L_0__R2, CL_class);
            clSetq(L_0__R1, clStaticClassWrapper(L_0__R2, clEOA)); }
          clSetq(L_1, clSetq(L_g7, clList(L_0__R1, clEOA))); }
        clRplacd(L_0, L_1, clEOA); }
      goto NEXT_LOOP;
      clLabel(END_LOOP);
      return(clCdr(L_g6, clEOA));
      return(clValues1(clNIL)); } } }

clObject clFindSlotDefinition clVdecl(_ap)
{ clObject CL_class, slot_name;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(slot_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject slot, L_g8;
    clSetq(slot, clNIL);
    { clObject L_0;
      clSetq(L_0, CL_class);
      clSetq(L_g8,
             clFuncallFunction(clSymbolFunctionValue(clCLASS_SLOTS),
                               L_0,
                               clEOA)); }
    clLabel(NEXT_LOOP);
    if (clTrue(clEndp(L_g8, clEOA))) goto END_LOOP;
    clSetq(slot, clCar(L_g8, clEOA));
    { clObject L_0;
      clSetq(L_0, L_g8);
      clSetq(L_g8, clCdr(L_0, clEOA)); }
    { clObject L_test;
      { clObject L_1, L_0;
        clSetq(L_0, slot_name);
        { clObject L_0__R1;
          clSetq(L_0__R1, slot);
          clSetq(L_1,
                 clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_NAME),
                                   L_0__R1,
                                   clEOA)); }
        clSetq(L_test, clEq(L_0, L_1, clEOA)); }
      if (clTrue(L_test)) return(clValues1(slot)); }
    goto NEXT_LOOP;
    clLabel(END_LOOP);
    return(clValues1(clNIL)); } }

clObject clSlotExistsP clVdecl(_ap)
{ clObject instance, slot_name;
  { clBeginParse(_ap);
    clSetq(instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(slot_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject CL_class;
    { clObject L_0;
      clSetq(L_0, instance);
      clSetq(CL_class, clClassOf(L_0, clEOA)); }
    { clObject L_0;
      { clObject L_0__R1;
        { clObject L_1;
          clSetq(L_1, slot_name);
          clSetq(L_0__R1, clFastFindSlot(CL_class, L_1)); }
        clSetq(L_0, clNull(L_0__R1, clEOA)); }
      return(clNot(L_0, clEOA)); } } }

clObject clSlotBoundp clVdecl(_ap)
{ clObject instance, slot_name;
  { clBeginParse(_ap);
    clSetq(instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(slot_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject CL_class, slot_definition;
    { clObject L_0;
      clSetq(L_0, instance);
      clSetq(CL_class, clClassOf(L_0, clEOA)); }
    { clObject L_1;
      clSetq(L_1, slot_name);
      clSetq(slot_definition, clFastFindSlot(CL_class, L_1)); }
    if (clTrue(slot_definition))
      { clObject L_1;
        clSetq(L_1, instance);
        return(clFuncallFunction(clSymbolFunctionValue(clSLOT_BOUNDP_USING_CLASS),
                                 CL_class,
                                 L_1,
                                 slot_definition,
                                 clEOA)); }
    else
      { clObject L_0;
        { clObject L_2, L_1;
          clSetq(L_1, instance);
          clSetq(L_2, slot_name);
          clSetq(L_0,
                 clFuncallFunction(clSymbolFunctionValue(clSLOT_MISSING),
                                   CL_class,
                                   L_1,
                                   L_2,
                                   clSLOT_BOUNDP,
                                   clEOA)); }
        return(clValues(L_0, clEOA)); } } }

clObject clSlotValue clVdecl(_ap)
{ clObject instance, slot_name;
  { clBeginParse(_ap);
    clSetq(instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(slot_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject CL_class, slot_definition;
    { clObject L_0;
      clSetq(L_0, instance);
      clSetq(CL_class, clClassOf(L_0, clEOA)); }
    { clObject L_1;
      clSetq(L_1, slot_name);
      clSetq(slot_definition, clFastFindSlot(CL_class, L_1)); }
    if (clTrue(slot_definition))
      { clObject L_1;
        clSetq(L_1, instance);
        return(clFuncallFunction(clSymbolFunctionValue(clSLOT_VALUE_USING_CLASS),
                                 CL_class,
                                 L_1,
                                 slot_definition,
                                 clEOA)); }
    else
      { clObject L_0;
        { clObject L_2, L_1;
          clSetq(L_1, instance);
          clSetq(L_2, slot_name);
          clSetq(L_0,
                 clFuncallFunction(clSymbolFunctionValue(clSLOT_MISSING),
                                   CL_class,
                                   L_1,
                                   L_2,
                                   clSLOT_VALUE,
                                   clEOA)); }
        return(clValues(L_0, clEOA)); } } }

clObject clSlotMakunbound clVdecl(_ap)
{ clObject instance, slot_name;
  { clBeginParse(_ap);
    clSetq(instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(slot_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject CL_class, slot_definition;
    { clObject L_0;
      clSetq(L_0, instance);
      clSetq(CL_class, clClassOf(L_0, clEOA)); }
    { clObject L_1;
      clSetq(L_1, slot_name);
      clSetq(slot_definition, clFastFindSlot(CL_class, L_1)); }
    if (clTrue(slot_definition))
      { clObject L_1;
        clSetq(L_1, instance);
        return(clFuncallFunction(clSymbolFunctionValue(clSLOT_MAKUNBOUND_USING_CLASS),
                                 CL_class,
                                 L_1,
                                 slot_definition,
                                 clEOA)); }
    else
      { { clObject L_2, L_1;
          clSetq(L_1, instance);
          clSetq(L_2, slot_name);
          clFuncallFunction(clSymbolFunctionValue(clSLOT_MISSING),
                            CL_class,
                            L_1,
                            L_2,
                            clSLOT_MAKUNBOUND,
                            clEOA); }
        return(clValues1(instance)); } } }

clObject cl_SETF_SlotValue clVdecl(_ap)
{ clObject new_value, instance, slot_name;
  { clBeginParse(_ap);
    clSetq(new_value,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(slot_name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject CL_class, slot_definition;
    { clObject L_0;
      clSetq(L_0, instance);
      clSetq(CL_class, clClassOf(L_0, clEOA)); }
    { clObject L_1;
      clSetq(L_1, slot_name);
      clSetq(slot_definition, clFastFindSlot(CL_class, L_1)); }
    if (clTrue(slot_definition))
      { clObject L_arg436, L_value434;
        clSetq(L_arg436, instance);
        clSetq(L_value434, new_value);
        return(clFuncallFunction(clFdefinition(CONS_2, clEOA),
                                 L_value434,
                                 CL_class,
                                 L_arg436,
                                 slot_definition,
                                 clEOA)); }
    else
      { { clObject L_4, L_2, L_1;
          clSetq(L_1, instance);
          clSetq(L_2, slot_name);
          clSetq(L_4, new_value);
          clFuncallFunction(clSymbolFunctionValue(clSLOT_MISSING),
                            CL_class,
                            L_1,
                            L_2,
                            clSETF,
                            L_4,
                            clEOA); }
        return(clValues1(new_value)); } } }

clDeclareEnv(clUpdateInstance_OldValue);
static clObject clUpdateInstance_OldValue clVdecl(_ap)
{ clUseEnv(clUpdateInstance_OldValue);
  { clObject old_slot;
    { clBeginParse(_ap);
      clSetq(old_slot,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject location;
      { clObject L_0;
        clSetq(L_0, old_slot);
        clSetq(location,
               clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_LOCATION),
                                 L_0,
                                 clEOA)); }
      if (clTrue(clConsp(location, clEOA)))
        return(clCdr(location, clEOA));
      else
        return(clValues1(clGetSlot(clEnv(0, *old_slots),
                                   location))); } } }

clObject clUpdateInstance clVdecl(_ap)
{ clObject instance, wrapper, CL_class;
  { clBeginParse(_ap);
    clSetq(instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(wrapper,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject old_slot_definitions, new_slot_definitions,
    *old_slots = clMakeBinding(), new_slots;
    { clObject L_0;
      clSetq(L_0, wrapper);
      clSetq(old_slot_definitions, clWrapperObsoleteSlots(L_0)); }
    { clObject L_0;
      clSetq(L_0, CL_class);
      clSetq(new_slot_definitions,
             clFuncallFunction(clSymbolFunctionValue(clCLASS_SLOTS),
                               L_0,
                               clEOA)); }
    { clObject L_0;
      clSetq(L_0, instance);
      clSetq(*old_slots, clStandardInstanceSlots(L_0)); }
    { clObject L_0;
      clSetq(L_0, instance);
      clSetq(new_slots,
             clSetStandardInstanceSlots(L_0,
                                        clMakeSlots(clNInstanceSlots(new_slot_definitions,
                                                                     clEOA)))); }
    { clObject L_1, L_0;
      clSetq(L_0, instance);
      { clObject L_0__R1;
        clSetq(L_0__R1, CL_class);
        clSetq(L_1,
               clFuncallFunction(clSymbolFunctionValue(clCLASS_WRAPPER),
                                 L_0__R1,
                                 clEOA)); }
      clSetTaggedInstanceWrapper(L_0, L_1); }
    { clObject _OldValue_;
      clSetq(_OldValue_,
             clMakeClosure(1,
                           clUpdateInstance_OldValue,
                           &clEnvHook(clUpdateInstance_OldValue),
                           &*old_slots));
      { clObject added_names, discarded_names, plist;
        clSetq(added_names, clNIL);
        clSetq(discarded_names, clNIL);
        clSetq(plist, clNIL);
        { clObject new_slot, L_g9;
          clSetq(new_slot, clNIL);
          clSetq(L_g9, new_slot_definitions);
          clLabel(NEXT_LOOP);
          if (clTrue(clEndp(L_g9, clEOA))) goto END_LOOP;
          clSetq(new_slot, clCar(L_g9, clEOA));
          { clObject L_0;
            clSetq(L_0, L_g9);
            clSetq(L_g9, clCdr(L_0, clEOA)); }
          { clObject L_test;
            { clObject L_0;
              clSetq(L_0, new_slot);
              clSetq(L_test, clLocalSlotP(L_0, clEOA)); }
            if (clTrue(L_test))
              { clObject name, old_slot;
                { clObject L_0;
                  clSetq(L_0, new_slot);
                  clSetq(name,
                         clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_NAME),
                                           L_0,
                                           clEOA)); }
                clSetq(old_slot,
                       clFind(name,
                              old_slot_definitions,
                              keyKEY,
                              clSymbolFunctionValue(clSLOT_DEFINITION_NAME),
                              clEOA));
                if (clTrue(old_slot))
                  { clObject L_1;
                    { clObject L_0__R1;
                      clSetq(L_0__R1, new_slot);
                      clSetq(L_1,
                             clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_LOCATION),
                                               L_0__R1,
                                               clEOA)); }
                    clSetSlot(new_slots,
                              L_1,
                              clFuncallFunction(_OldValue_,
                                                old_slot,
                                                clEOA)); }
                else
                  { clObject L_1;
                    clSetq(L_1, added_names);
                    clSetq(added_names,
                           clCons(name, L_1, clEOA)); } } }
          goto NEXT_LOOP;
          clLabel(END_LOOP); }
        { clObject old_slot, L_g10;
          clSetq(old_slot, clNIL);
          clSetq(L_g10, old_slot_definitions);
          clLabel(NEXT_LOOP__r1);
          if (clTrue(clEndp(L_g10, clEOA))) goto END_LOOP__r1;
          clSetq(old_slot, clCar(L_g10, clEOA));
          { clObject L_0;
            clSetq(L_0, L_g10);
            clSetq(L_g10, clCdr(L_0, clEOA)); }
          { clObject L_test;
            { clObject L_0;
              clSetq(L_0, old_slot);
              clSetq(L_test, clLocalSlotP(L_0, clEOA)); }
            if (clTrue(L_test))
              { clObject name, new_slot;
                { clObject L_0;
                  clSetq(L_0, old_slot);
                  clSetq(name,
                         clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_NAME),
                                           L_0,
                                           clEOA)); }
                clSetq(new_slot,
                       clFind(name,
                              new_slot_definitions,
                              keyKEY,
                              clSymbolFunctionValue(clSLOT_DEFINITION_NAME),
                              clEOA));
                if (clTrue(clNot(new_slot, clEOA)))
                  { { clObject L_1;
                      clSetq(L_1, discarded_names);
                      clSetq(discarded_names,
                             clCons(name, L_1, clEOA)); }
                    { clObject value;
                      { clObject L_0;
                        clSetq(L_0, old_slot);
                        clSetq(value,
                               clFuncallFunction(_OldValue_,
                                                 L_0,
                                                 clEOA)); }
                      if (clTrue(clNot(clUnboundp(value), clEOA)))
                      { clObject L_1, L_0;
                        clSetq(L_0, clList(name, value, clEOA));
                        clSetq(L_1, plist);
                        clSetq(plist,
                               clNconc(L_0, L_1, clEOA)); } } } } }
          goto NEXT_LOOP__r1;
          clLabel(END_LOOP__r1); }
        { clObject L_3, L_2, L_1, L_0;
          clSetq(L_0, instance);
          clSetq(L_1, added_names);
          clSetq(L_2, discarded_names);
          clSetq(L_3, plist);
          return(clFuncallFunction(clSymbolFunctionValue(clUPDATE_INSTANCE_FOR_REDEFINED_CLASS),
                                   L_0,
                                   L_1,
                                   L_2,
                                   L_3,
                                   clEOA)); } } } } }

clObject clUpdateInstancesIfNeeded clVdecl(_ap)
{ clObject instances;
  { clBeginParse(_ap);
    clSetq(instances,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_sublist438, instance;
    clSetq(L_sublist438, instances);
    clSetq(instance, clCar(L_sublist438, clEOA));
    clLabel(l_ITERATE439);
    if (clTrue(clEndp(L_sublist438, clEOA))) return(clValues1(clNIL));
    { clObject wrapper;
      clSetq(wrapper, clObjectWrapper(instance));
      if (clTrue(clWrapperInvalidP(wrapper)))
        clUpdateInstance(instance,
                         wrapper,
                         clTaggedInstanceClass(instance),
                         clEOA); }
    { clObject L_0;
      clSetq(L_0, L_sublist438);
      clSetq(L_sublist438, clCdr(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, L_sublist438);
      clSetq(instance, clCar(L_0, clEOA)); }
    goto l_ITERATE439; } }

clObject clSetGfLambdaList clVdecl(_ap)
{ clObject gf, lambda, apo;
  { clBeginParse(_ap);
    clSetq(gf, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(lambda,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(apo,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_instance440, L_class441, L_allow_other_keys_p446,
    L_keywords445, L_required_parameters444, L_lambda_list443,
    L_argument_precedence_order442;
    clSetq(L_instance440, gf);
    clSetq(L_class441, clClassOf(L_instance440, clEOA));
    clSetq(L_allow_other_keys_p446,
           clFastFindSlot(L_class441, clALLOW_OTHER_KEYS_P));
    clSetq(L_keywords445, clFastFindSlot(L_class441, clKEYWORDS));
    clSetq(L_required_parameters444,
           clFastFindSlot(L_class441, clREQUIRED_PARAMETERS));
    clSetq(L_lambda_list443,
           clFastFindSlot(L_class441, clLAMBDA_LIST));
    clSetq(L_argument_precedence_order442,
           clFastFindSlot(L_class441, clARGUMENT_PRECEDENCE_ORDER));
    { clObject required, keys;
      { clObject parameter, L_g11;
        clSetq(parameter, clNIL);
        clSetq(L_g11, lambda);
        { clObject L_g12, L_g13, result;
          clSetq(L_g12, clList(clNIL, clEOA));
          clSetq(L_g13, L_g12);
          clSetq(result, clNIL);
          clLabel(NEXT_LOOP);
          if (clTrue(clEndp(L_g11, clEOA))) goto END_LOOP;
          clSetq(parameter, clCar(L_g11, clEOA));
          { clObject L_0;
            clSetq(L_0, L_g11);
            clSetq(L_g11, clCdr(L_0, clEOA)); }
          { clObject L_test;
            { clObject L_0;
              clSetq(L_0, parameter);
              clSetq(L_test, clLambdaListKeywordP(L_0, clEOA)); }
            if (clTrue(L_test))
              { clSetq(required, result); clLocalReturn(NIL); } }
          { clObject L_1, L_0;
            clSetq(L_0, L_g13);
            { clObject L_0__R1;
              clSetq(L_0__R1, parameter);
              clSetq(L_1, clSetq(L_g13, clList(L_0__R1, clEOA))); }
            clRplacd(L_0, L_1, clEOA); }
          clSetq(result, clCdr(L_g12, clEOA));
          goto NEXT_LOOP;
          clLabel(END_LOOP);
          clSetq(required, result);
          clLocalReturn(NIL);
          clSetq(required, clNIL);
          clBlockEnd(NIL); } }
      { clObject L_sub447;
        clSetq(L_sub447, lambda);
        clLabel(l_ITERATE450);
        if (clTrue(clEndp(L_sub447, clEOA)))
          { clSetq(keys, clNIL); clLocalReturn(NIL__r1); }
        if (_clEq(clampersandKEY, clCar(L_sub447, clEOA)))
          { clSetq(keys, L_sub447); clLocalReturn(l_MEMBER449); }
        { clObject L_value451;
          clSetq(L_value451, clCdr(L_sub447, clEOA));
          clSetq(L_sub447, L_value451); }
        goto l_ITERATE450; }
      clBlockEnd(NIL__r1);
      clBlockEnd(l_MEMBER449);
      { clObject L_value452;
        clSetq(L_value452, lambda);
        clFuncallFunction(clFdefinition(CONS_2, clEOA),
                          L_value452,
                          L_class441,
                          L_instance440,
                          L_lambda_list443,
                          clEOA); }
      { clObject L_value456;
        clSetq(L_value456, required);
        clFuncallFunction(clFdefinition(CONS_2, clEOA),
                          L_value456,
                          L_class441,
                          L_instance440,
                          L_required_parameters444,
                          clEOA); }
      { clObject L_value460;
        { clObject L_0;
          clSetq(L_0, keys);
          clSetq(L_value460, clExtractKeywords(L_0, clEOA)); }
        clFuncallFunction(clFdefinition(CONS_2, clEOA),
                          L_value460,
                          L_class441,
                          L_instance440,
                          L_keywords445,
                          clEOA); }
      { clObject L_value464;
        { clObject L_g472;
          { clObject L_0;
            clSetq(L_0, keys);
            clSetq(L_g472, clNull(L_0, clEOA)); }
          if (clTrue(L_g472))
            clSetq(L_value464, L_g472);
          else
            { clObject L_1;
              clSetq(L_1, keys);
              clSetq(L_value464,
                     clFastFind(clampersandALLOW_OTHER_KEYS, L_1)); } }
        { clObject L_0;
          clSetq(L_0, L_value464);
          clFuncallFunction(clFdefinition(CONS_2, clEOA),
                            L_0,
                            L_class441,
                            L_instance440,
                            L_allow_other_keys_p446,
                            clEOA); } }
      { clObject L_value468;
        if (clTrue(apo))
          { clObject L_test__R1;
            { clObject L_1, L_0;
              clSetq(L_0, apo);
              clSetq(L_1, required);
              clSetq(L_test__R1, clListEq(L_0, L_1, clEOA)); }
            if (clTrue(L_test__R1))
              clSetq(L_value468, required);
            else
              { clObject L_test__R2;
                { clObject L_1, L_0;
                  clSetq(L_0, required);
                  clSetq(L_1, apo);
                  clSetq(L_test__R2,
                         clSetExclusiveOr(L_0, L_1, clEOA)); }
                if (clTrue(L_test__R2))
                  { clObject L_1;
                    clSetq(L_1, apo);
                    clSetq(L_value468,
                           clSignalProgramError(STRn_7, L_1, clEOA)); }
                else clSetq(L_value468, apo); } }
        else clSetq(L_value468, required);
        { clObject L_0;
          clSetq(L_0, L_value468);
          clFuncallFunction(clFdefinition(CONS_2, clEOA),
                            L_0,
                            L_class441,
                            L_instance440,
                            L_argument_precedence_order442,
                            clEOA); } } }
    { clObject L_test;
      { clObject L_0;
        clSetq(L_0, gf);
        clSetq(L_test, clSlotBoundp(L_0, clMETHODS, clEOA)); }
      if (clTrue(L_test))
        { clObject L_sublist473, method;
          { clObject L_0;
            clSetq(L_0, gf);
            clSetq(L_sublist473,
                   clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_METHODS),
                                     L_0,
                                     clEOA)); }
          clSetq(method, clCar(L_sublist473, clEOA));
          clLabel(l_ITERATE474);
          if (clTrue(clEndp(L_sublist473, clEOA)))
            return(clValues1(clNIL));
          { clObject L_0;
            clSetq(L_0, gf);
            clCheckCongruentLambda(L_0, method, clEOA); }
          { clObject L_0;
            clSetq(L_0, L_sublist473);
            clSetq(L_sublist473, clCdr(L_0, clEOA)); }
          { clObject L_0;
            clSetq(L_0, L_sublist473);
            clSetq(method, clCar(L_0, clEOA)); }
          goto l_ITERATE474; }
      else return(clValues1(clNIL)); } } }

clObject clFinalizeGenericFunction clVdecl(_ap)
{ clObject generic_function;
  { clBeginParse(_ap);
    clSetq(generic_function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_0;
      clSetq(L_0, generic_function);
      clSetq(L_test, clSlotBoundp(L_0, clLAMBDA_LIST, clEOA)); }
    if (clTrue(L_test))
      { { clObject L_1, L_0;
          clSetq(L_0, generic_function);
          { clObject L_0__R1;
            clSetq(L_0__R1, generic_function);
            clSetq(L_1,
                   clFuncallFunction(clSymbolFunctionValue(clCOMPUTE_DISCRIMINATING_FUNCTION),
                                     L_0__R1,
                                     clEOA)); }
          clSetFuncallableInstanceFunction(L_0, L_1, clEOA); }
        { clObject L_0;
          clSetq(L_0, generic_function);
          clFuncallFunction(clSymbolFunctionValue(clFLUSH_METHOD_CACHE),
                            L_0,
                            clEOA); } } }
  return(clValues1(generic_function)); }

clObject clApplyMethod clVdecl(_ap)
{ clObject L_form, L_ignored, method, args, other_data;
  { clBeginParse(_ap);
    clSetq(L_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(L_ignored,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    { clObject L_0;
      clSetq(L_0, L_form);
      clSetq(L_form, clCdr(L_0, clEOA)); }
    if (clTrue(L_form))
      { clObject L_top477;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top477, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(method, L_top477); }
    else clSetq(method, clMissingArgs(I_1, clEOA));
    if (clTrue(L_form))
      { clObject L_top478;
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_top478, clCar(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_form);
          clSetq(L_form, clCdr(L_0, clEOA)); }
        clSetq(args, L_top478); }
    else clSetq(args, clMissingArgs(I_2, clEOA));
    clSetq(other_data, L_form);
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_2, L_1;
    { clObject L_1__R1;
      clSetq(L_1__R1, method);
      clSetq(L_1, clList(clMETHOD_FUNCTION, L_1__R1, clEOA)); }
    clSetq(L_2, args);
    return(clListSTAR(clFUNCALL_FUNCTION,
                      L_1,
                      L_2,
                      other_data,
                      clEOA)); } }

clObject clMakeInternalMethod clVdecl(_ap)
{ clObject function;
  { clBeginParse(_ap);
    clSetq(function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_2;
    clSetq(L_2, function);
    return(clFuncallFunction(clSymbolFunctionValue(clMAKE_INSTANCE),
                             clSTANDARD_METHOD_CLASSOBJ,
                             keyFUNCTION,
                             L_2,
                             clEOA)); } }

clDeclareEnv(clSortApplicableMethods_Lambda);
static clObject clSortApplicableMethods_Lambda clVdecl(_ap)
{ clUseEnv(clSortApplicableMethods_Lambda);
  { clObject m1, m2;
    { clBeginParse(_ap);
      clSetq(m1,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(m2,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
      if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
      clEndParse(_ap); }
    { clObject L_3, L_2, L_1, L_0;
      clSetq(L_0, clEnv(0, *gf));
      clSetq(L_1, m1);
      clSetq(L_2, m2);
      clSetq(L_3, clEnv(1, *arg_classes));
      return(clStdMethodMoreSpecificP(L_0, L_1, L_2, L_3, clEOA)); } } }

clObject clSortApplicableMethods clVdecl(_ap)
{ clObject *gf = clMakeBinding(), applicable_methods,
  *arg_classes = clMakeBinding();
  { clBeginParse(_ap);
    clSetq(*gf,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(applicable_methods,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(*arg_classes,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_2, L_0;
    clSetq(L_0, applicable_methods);
    clSetq(L_2,
           clMakeClosure(2,
                         clSortApplicableMethods_Lambda,
                         &clEnvHook(clSortApplicableMethods_Lambda),
                         &*gf,
                         &*arg_classes));
    return(clQuicksortList(L_0, clNIL, L_2, clNIL, clEOA)); } }

clObject clCallMethodMacrolet clVdecl(_ap)
{ clObject form, args;
  { clBeginParse(_ap);
    clSetq(form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(args,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_2, L_1;
    { clObject L_0__R1;
      { clObject L_2__R1;
        { clObject L_2__R2;
          { clObject L_1__R3;
            clSetq(L_1__R3, args);
            clSetq(L_2__R2, clList(clQUOTE, L_1__R3, clEOA)); }
          clSetq(L_2__R1,
                 clListSTAR(clCALL_METHOD_EXPANSION,
                            clM,
                            L_2__R2,
                            CONS_8,
                            clEOA)); }
        clSetq(L_0__R1,
               clList(clCALL_METHOD, CONS_6, L_2__R1, clEOA)); }
      clSetq(L_1, clList(L_0__R1, clEOA)); }
    clSetq(L_2, form);
    return(clList(clMACROLET, L_1, L_2, clEOA)); } }

clObject clMakeMethodExpansion clVdecl(_ap)
{ clObject make_method_form, args;
  { clBeginParse(_ap);
    clSetq(make_method_form,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(args,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_1, L_0;
    { clObject L_0__R1;
      clSetq(L_0__R1, make_method_form);
      clSetq(L_0, clSecond(L_0__R1, clEOA)); }
    clSetq(L_1, args);
    return(clCallMethodMacrolet(L_0, L_1, clEOA)); } }

clObject clCallMethodExpansion clVdecl(_ap)
{ clObject method, args, other_data;
  { clBeginParse(_ap);
    clSetq(method,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(args,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(other_data,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_test;
    { clObject L_0;
      clSetq(L_0, method);
      clSetq(L_test, clCarEq(L_0, clMAKE_METHOD, clEOA)); }
    if (clTrue(L_test))
      { clObject L_1, L_0;
        clSetq(L_0, method);
        clSetq(L_1, args);
        return(clMakeMethodExpansion(L_0, L_1, clEOA)); }
    else
      { clObject L_3, L_2, L_1;
        clSetq(L_1, method);
        clSetq(L_2, args);
        { clObject L_test__R1;
          { clObject L_0__R1;
            { clObject L_0__R2;
              clSetq(L_0__R2, other_data);
              clSetq(L_0__R1, clCar(L_0__R2, clEOA)); }
            clSetq(L_test__R1, clConsp(L_0__R1, clEOA)); }
          if (clTrue(L_test__R1))
            { clObject L_1__R1, L_0__R1;
              { clObject L_1__R2;
                { clObject method__R1, L_g14;
                  clSetq(method__R1, clNIL);
                  { clObject L_0__R3;
                    clSetq(L_0__R3, other_data);
                    clSetq(L_g14, clCar(L_0__R3, clEOA)); }
                  { clObject L_g15, L_g16;
                    clSetq(L_g15, clList(clNIL, clEOA));
                    clSetq(L_g16, L_g15);
                    clLabel(NEXT_LOOP);
                    if (clTrue(clEndp(L_g14, clEOA))) goto END_LOOP;
                    clSetq(method__R1, clCar(L_g14, clEOA));
                    { clObject L_0__R3;
                      clSetq(L_0__R3, L_g14);
                      clSetq(L_g14, clCdr(L_0__R3, clEOA)); }
                    { clObject L_1__R3, L_0__R3;
                      clSetq(L_0__R3, L_g16);
                      { clObject L_0__R4;
                        { clObject L_test__R2;
                          { clObject L_0__R5;
                            clSetq(L_0__R5, method__R1);
                            clSetq(L_test__R2,
                                   clCarEq(L_0__R5,
                                           clMAKE_METHOD,
                                           clEOA)); }
                          if (clTrue(L_test__R2))
                          { clObject L_1__R4;
                            { clObject L_1__R5;
                              { clObject L_3__R1;
                                { clObject L_0__R8;
                                  clSetq(L_0__R8, method__R1);
                                  clSetq(L_3__R1,
                                         clMakeMethodExpansion(L_0__R8,
                                                               clARGS,
                                                               clEOA)); }
                                clSetq(L_1__R5,
                                       clList(clLAMBDA,
                                              CONS_9,
                                              CONS_12,
                                              L_3__R1,
                                              clEOA)); }
                              clSetq(L_1__R4,
                                     clList(clFUNCTION,
                                            L_1__R5,
                                            clEOA)); }
                            clSetq(L_0__R4,
                                   clList(clMAKE_INTERNAL_METHOD,
                                          L_1__R4,
                                          clEOA)); }
                          else
                          clSetq(L_0__R4, method__R1); }
                        clSetq(L_1__R3,
                               clSetq(L_g16,
                                      clList(L_0__R4, clEOA))); }
                      clRplacd(L_0__R3, L_1__R3, clEOA); }
                    goto NEXT_LOOP;
                    clLabel(END_LOOP);
                    clSetq(L_1__R2, clCdr(L_g15, clEOA));
                    clLocalReturn(NIL__r2);
                    clSetq(L_1__R2, clNIL);
                    clBlockEnd(NIL__r2); } }
                clSetq(L_0__R1, clCons(clLIST, L_1__R2, clEOA)); }
              { clObject L_0__R2;
                clSetq(L_0__R2, other_data);
                clSetq(L_1__R1, clRest(L_0__R2, clEOA)); }
              clSetq(L_3, clListSTAR(L_0__R1, L_1__R1, clEOA)); }
          else clSetq(L_3, other_data); }
        return(clListSTAR(clAPPLY_METHOD, L_1, L_2, L_3, clEOA)); } } }

clDeclareEnv(clStandardDiscriminatingFunction_Lambda);
static clObject clStandardDiscriminatingFunction_Lambda clVdecl(_ap)
{ clUseEnv(clStandardDiscriminatingFunction_Lambda);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject table, emfun;
      { clObject L_0;
        clSetq(L_0, clEnv(0, *generic_function));
        clSetq(table, clEmfTable(L_0)); }
      { clObject L_1;
        clSetq(L_1, clEnv(1, *n));
        clSetq(emfun, clEmfTableGet(table, L_1, args)); }
      if (clTrue(emfun))
        return(clApplyFunction(emfun, args, clEOA));
      else
        { clObject classes;
          { clObject L_g17;
            clSetq(L_g17, clEnv(1, *n));
            { clObject arg, L_g18;
              clSetq(arg, clNIL);
              clSetq(L_g18, args);
              { clObject L_g19, L_g20;
                clSetq(L_g19, clList(clNIL, clEOA));
                clSetq(L_g20, L_g19);
                clLabel(NEXT_LOOP);
                { clObject L_test__R1;
                  { clObject L_0;
                    { clObject L_0__R1;
                      clSetq(L_0__R1, L_g17);
                      clSetq(L_0,
                             clSetq(L_g17,
                                    clSubtIntegerInteger(L_0__R1, I_1))); }
                    clSetq(L_test__R1, clLtIntegerInteger(L_0, I_0)); }
                  if (clTrue(L_test__R1)) goto END_LOOP; }
                if (clTrue(clEndp(L_g18, clEOA))) goto END_LOOP;
                clSetq(arg, clCar(L_g18, clEOA));
                { clObject L_0;
                  clSetq(L_0, L_g18);
                  clSetq(L_g18, clCdr(L_0, clEOA)); }
                { clObject L_1, L_0;
                  clSetq(L_0, L_g20);
                  { clObject L_0__R1;
                    { clObject L_0__R2;
                      clSetq(L_0__R2, arg);
                      clSetq(L_0__R1, clClassOf(L_0__R2, clEOA)); }
                    clSetq(L_1,
                           clSetq(L_g20, clList(L_0__R1, clEOA))); }
                  clRplacd(L_0, L_1, clEOA); }
                goto NEXT_LOOP;
                clLabel(END_LOOP);
                clSetq(classes, clCdr(L_g19, clEOA));
                clLocalReturn(NIL);
                clSetq(classes, clNIL);
                clBlockEnd(NIL); } } }
          { clObject L_values479, applicable_methods, by_class_p;
            { clMultipleValueCall(MVC);
              clSetq(MVC, clSymbolFunctionValue(clLIST));
              { clObject L_1, L_0;
                clSetq(L_0, clEnv(0, *generic_function));
                clSetq(L_1, classes);
                clFuncallFunction(clSymbolFunctionValue(clCOMPUTE_APPLICABLE_METHODS_USING_CLASSES),
                                  L_0,
                                  L_1,
                                  clEOA); }
              clAccumulateValues(MVC);
              clSetq(L_values479, clMultipleValueFuncall(MVC)); }
            clSetq(applicable_methods, clCar(L_values479, clEOA));
            { clObject L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, L_values479);
                clSetq(L_0,
                       clSetq(L_values479, clCdr(L_0__R1, clEOA))); }
              clSetq(by_class_p, clCar(L_0, clEOA)); }
            if (clTrue(clNot(by_class_p, clEOA)))
              { clObject L_0;
                clSetq(L_0, clEnv(0, *generic_function));
                clSetq(applicable_methods,
                       clFuncallFunction(clSymbolFunctionValue(clCOMPUTE_APPLICABLE_METHODS),
                                         L_0,
                                         args,
                                         clEOA)); }
            { clObject emfun__R1;
              { clObject L_3, L_2, L_1, L_0;
                clSetq(L_0, clEnv(0, *generic_function));
                { clObject L_0__R1;
                  clSetq(L_0__R1, clEnv(0, *generic_function));
                  clSetq(L_1,
                         clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_METHOD_COMBINATION),
                                           L_0__R1,
                                           clEOA)); }
                clSetq(L_2, applicable_methods);
                clSetq(L_3, classes);
                clSetq(emfun__R1,
                       clComputeEffectiveMethodFunction(L_0,
                                                        L_1,
                                                        L_2,
                                                        L_3,
                                                        clEOA)); }
              if (clTrue(by_class_p))
                { clObject L_2, L_1;
                  clSetq(L_1, clEnv(1, *n));
                  clSetq(L_2, classes);
                  clEmfTableSet(table, L_1, L_2, emfun__R1); }
              return(clApplyFunction(emfun__R1,
                                     args,
                                     clEOA)); } } } } } }

clObject clStandardDiscriminatingFunction clVdecl(_ap)
{ clObject *generic_function = clMakeBinding(), *n = clMakeBinding();
  { clBeginParse(_ap);
    clSetq(*generic_function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(*n, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clValues1(clMakeClosure(2,
                                 clStandardDiscriminatingFunction_Lambda,
                                 &clEnvHook(clStandardDiscriminatingFunction_Lambda),
                                 &*generic_function,
                                 &*n))); }

clDeclareEnv(clComputeEffectiveMethodFunction_Lambda);
static clObject clComputeEffectiveMethodFunction_Lambda clVdecl(_ap)
{ clUseEnv(clComputeEffectiveMethodFunction_Lambda);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject L_1, L_0;
      clSetq(L_0, clSymbolFunctionValue(clNO_APPLICABLE_METHOD));
      clSetq(L_1, clEnv(0, *generic_function));
      return(clApply(L_0, L_1, args, clEOA)); } } }

clObject clComputeEffectiveMethodFunction clVdecl(_ap)
{ clObject *generic_function = clMakeBinding(), method_combination,
  applicable_methods, argument_classes;
  { clBeginParse(_ap);
    clSetq(*generic_function,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(method_combination,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(applicable_methods,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(argument_classes,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_4, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  if (clTrue(applicable_methods))
    { clObject L_test__R1;
      { clObject L_test__R2;
        { clObject L_0;
          clSetq(L_0, method_combination);
          clSetq(L_test__R2,
                 clEq(L_0,
                      clSymbolValue(clstarSTANDARD_METHOD_COMBINATIONstar,
                                    clEOA),
                      clEOA)); }
        if (clTrue(L_test__R2))
          { clObject meta;
            { clObject L_0;
              clSetq(L_0, *generic_function);
              clSetq(meta, clClassOf(L_0, clEOA)); }
            { clObject L_g480;
              clSetq(L_g480,
                     clEq(meta,
                          clSTANDARD_GENERIC_FUNCTION_CLASSOBJ,
                          clEOA));
              clSetq(L_test__R1,
                     (clTrue(L_g480) ?
                      L_g480 :
                      clEq(meta,
                           clSTANDARD_SYSTEM_GENERIC_FUNCTION_CLASSOBJ,
                           clEOA))); } }
        else clSetq(L_test__R1, clNIL); }
      if (clTrue(L_test__R1))
        { clObject L_2, L_1, L_0;
          clSetq(L_0, *generic_function);
          clSetq(L_1, applicable_methods);
          clSetq(L_2, argument_classes);
          return(clComputeStandardEffectiveMethodFunction(L_0,
                                                          L_1,
                                                          L_2,
                                                          clEOA)); }
      else
        { clObject L_1, L_0;
          { clObject L_2, L_1__R1, L_0__R1;
            clSetq(L_0__R1, *generic_function);
            clSetq(L_1__R1, method_combination);
            clSetq(L_2, applicable_methods);
            clSetq(L_0,
                   clMakeEffectiveMethodLambda(L_0__R1,
                                               L_1__R1,
                                               L_2,
                                               clEOA)); }
          { clObject L_0__R1;
            clSetq(L_0__R1, *generic_function);
            clSetq(L_1,
                   clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_NAME),
                                     L_0__R1,
                                     clEOA)); }
          return(clFuncallFunction(clSymbolFunctionValue(clCOMPILE_OBJECT),
                                   L_0,
                                   L_1,
                                   clEOA)); } }
  else
    return(clValues1(clMakeClosure(1,
                                   clComputeEffectiveMethodFunction_Lambda,
                                   &clEnvHook(clComputeEffectiveMethodFunction_Lambda),
                                   &*generic_function))); }

clDeclareEnv(clComputeMethodFunction_Lambda);
static clObject clComputeMethodFunction_Lambda clVdecl(_ap)
{ clUseEnv(clComputeMethodFunction_Lambda);
  { clObject args, ignore;
    { clBeginParse(_ap);
      clSetq(args,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(ignore, clVargs(_ap));
      clEndParse(_ap); }
    { clObject L_form487, instance;
      clSetq(L_form487, args);
      if (clTrue(L_form487))
        { clObject L_top488;
          clSetq(L_top488, clCar(L_form487, clEOA));
          { clObject L_0;
            clSetq(L_0, L_form487);
            clSetq(L_form487, clCdr(L_0, clEOA)); }
          clSetq(instance, L_top488); }
      else clSetq(instance, clMissingArgs(I_1, clEOA));
      if (clTrue(L_form487))
        { clObject L_0;
          clSetq(L_0, L_form487);
          clExtraArgs(L_0, clEOA); }
      return(clCdr(clEnv(0, *location), clEOA)); } } }

clDeclareEnv(clComputeMethodFunction_Lambda_r1);
static clObject clComputeMethodFunction_Lambda_r1 clVdecl(_ap)
{ clUseEnv(clComputeMethodFunction_Lambda_r1);
  { clObject args, ignore;
    { clBeginParse(_ap);
      clSetq(args,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(ignore, clVargs(_ap));
      clEndParse(_ap); }
    { clObject L_form492, instance;
      clSetq(L_form492, args);
      if (clTrue(L_form492))
        { clObject L_top493;
          clSetq(L_top493, clCar(L_form492, clEOA));
          { clObject L_0;
            clSetq(L_0, L_form492);
            clSetq(L_form492, clCdr(L_0, clEOA)); }
          clSetq(instance, L_top493); }
      else clSetq(instance, clMissingArgs(I_1, clEOA));
      if (clTrue(L_form492))
        { clObject L_0;
          clSetq(L_0, L_form492);
          clExtraArgs(L_0, clEOA); }
      { clObject L_1, L_0;
        clSetq(L_0, instance);
        clSetq(L_1, clEnv(0, *location));
        return(clStandardInstanceAccess(L_0, L_1, clEOA)); } } } }

clDeclareEnv(clComputeMethodFunction_Lambda_r2);
static clObject clComputeMethodFunction_Lambda_r2 clVdecl(_ap)
{ clUseEnv(clComputeMethodFunction_Lambda_r2);
  { clObject args, ignore;
    { clBeginParse(_ap);
      clSetq(args,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(ignore, clVargs(_ap));
      clEndParse(_ap); }
    { clObject L_form497, CL_new, instance;
      clSetq(L_form497, args);
      if (clTrue(L_form497))
        { clObject L_top498;
          clSetq(L_top498, clCar(L_form497, clEOA));
          { clObject L_0;
            clSetq(L_0, L_form497);
            clSetq(L_form497, clCdr(L_0, clEOA)); }
          clSetq(CL_new, L_top498); }
      else clSetq(CL_new, clMissingArgs(I_1, clEOA));
      if (clTrue(L_form497))
        { clObject L_top499;
          { clObject L_0;
            clSetq(L_0, L_form497);
            clSetq(L_top499, clCar(L_0, clEOA)); }
          { clObject L_0;
            clSetq(L_0, L_form497);
            clSetq(L_form497, clCdr(L_0, clEOA)); }
          clSetq(instance, L_top499); }
      else clSetq(instance, clMissingArgs(I_2, clEOA));
      if (clTrue(L_form497))
        { clObject L_0;
          clSetq(L_0, L_form497);
          clExtraArgs(L_0, clEOA); }
      { clObject L_g500, L_g501;
        clSetq(L_g500, clEnv(0, *location));
        clSetq(L_g501, CL_new);
        clRplacd(L_g500, L_g501, clEOA);
        return(clValues1(L_g501)); } } } }

clDeclareEnv(clComputeMethodFunction_Lambda_r3);
static clObject clComputeMethodFunction_Lambda_r3 clVdecl(_ap)
{ clUseEnv(clComputeMethodFunction_Lambda_r3);
  { clObject args, ignore;
    { clBeginParse(_ap);
      clSetq(args,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(ignore, clVargs(_ap));
      clEndParse(_ap); }
    { clObject L_form505, CL_new, instance;
      clSetq(L_form505, args);
      if (clTrue(L_form505))
        { clObject L_top506;
          clSetq(L_top506, clCar(L_form505, clEOA));
          { clObject L_0;
            clSetq(L_0, L_form505);
            clSetq(L_form505, clCdr(L_0, clEOA)); }
          clSetq(CL_new, L_top506); }
      else clSetq(CL_new, clMissingArgs(I_1, clEOA));
      if (clTrue(L_form505))
        { clObject L_top507;
          { clObject L_0;
            clSetq(L_0, L_form505);
            clSetq(L_top507, clCar(L_0, clEOA)); }
          { clObject L_0;
            clSetq(L_0, L_form505);
            clSetq(L_form505, clCdr(L_0, clEOA)); }
          clSetq(instance, L_top507); }
      else clSetq(instance, clMissingArgs(I_2, clEOA));
      if (clTrue(L_form505))
        { clObject L_0;
          clSetq(L_0, L_form505);
          clExtraArgs(L_0, clEOA); }
      { clObject L_g508, L_g509, L_g510;
        clSetq(L_g508, instance);
        clSetq(L_g509, clEnv(0, *location));
        clSetq(L_g510, CL_new);
        { clObject L_1, L_0;
          clSetq(L_0, clStandardInstanceSlots(L_g508));
          clSetq(L_1, clFixnumIndex(L_g509));
          return(clValues1(clSetSlot(L_0, L_1, L_g510))); } } } } }

clObject clComputeMethodFunction clVdecl(_ap)
{ clObject method, argument_classes;
  { clBeginParse(_ap);
    clSetq(method,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(argument_classes,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject readerp;
    { clObject L_0;
      clSetq(L_0, method);
      clSetq(readerp,
             clClassp(L_0,
                      clSTANDARD_READER_METHOD_CLASSOBJ,
                      clEOA)); }
    { clObject L_g481;
      { clObject L_test;
        if (clTrue(readerp))
          clSetq(L_test, readerp);
        else
          { clObject L_0;
            clSetq(L_0, method);
            clSetq(L_test,
                   clClassp(L_0,
                            clSTANDARD_WRITER_METHOD_CLASSOBJ,
                            clEOA)); }
        if (clTrue(L_test))
          { clObject direct_slot, main_class, slot;
            { clObject L_0;
              clSetq(L_0, method);
              clSetq(direct_slot,
                     clFuncallFunction(clSymbolFunctionValue(clACCESSOR_METHOD_SLOT_DEFINITION),
                                       L_0,
                                       clEOA)); }
            if (clTrue(readerp))
              { clObject L_0;
                clSetq(L_0, argument_classes);
                clSetq(main_class, clFirst(L_0, clEOA)); }
            else
              { clObject L_0;
                clSetq(L_0, argument_classes);
                clSetq(main_class, clSecond(L_0, clEOA)); }
            { clObject L_0;
              clSetq(L_0, main_class);
              clSetq(slot,
                     clFastFindSlot(L_0,
                                    clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_NAME),
                                                      direct_slot,
                                                      clEOA))); }
            { clObject L_values483, methods, by_classp;
              { clMultipleValueCall(MVC);
                clSetq(MVC, clSymbolFunctionValue(clLIST));
                { clObject L_1, L_0;
                  { clObject L_0__R1;
                    clSetq(L_0__R1,
                           (clTrue(readerp) ?
                            clSLOT_VALUE_USING_CLASS :
                            CONS_17));
                    clSetq(L_0, clFdefinition(L_0__R1, clEOA)); }
                  { clObject value_classes;
                    { clObject L_1__R1, L_0__R1;
                      { clObject L_0__R2;
                        clSetq(L_0__R2, main_class);
                        clSetq(L_0__R1, clClassOf(L_0__R2, clEOA)); }
                      clSetq(L_1__R1, main_class);
                      clSetq(value_classes,
                             clList(L_0__R1,
                                    L_1__R1,
                                    clClassOf(slot, clEOA),
                                    clEOA)); }
                    if (clTrue(readerp))
                      clSetq(L_1, value_classes);
                    else
                      { clObject L_0__R1;
                        { clObject L_0__R2;
                          clSetq(L_0__R2, argument_classes);
                          clSetq(L_0__R1, clFirst(L_0__R2, clEOA)); }
                        clSetq(L_1,
                               clCons(L_0__R1,
                                      value_classes,
                                      clEOA)); } }
                  clFuncallFunction(clSymbolFunctionValue(clCOMPUTE_APPLICABLE_METHODS_USING_CLASSES),
                                    L_0,
                                    L_1,
                                    clEOA); }
                clAccumulateValues(MVC);
                clSetq(L_values483, clMultipleValueFuncall(MVC)); }
              clSetq(methods, clCar(L_values483, clEOA));
              { clObject L_0;
                { clObject L_0__R1;
                  clSetq(L_0__R1, L_values483);
                  clSetq(L_0,
                         clSetq(L_values483, clCdr(L_0__R1, clEOA))); }
                clSetq(by_classp, clCar(L_0, clEOA)); }
              if (clTrue((clTrue(by_classp) ?
                          clNull(clRest(methods, clEOA), clEOA) :
                          clNIL)))
                { clObject *location = clMakeBinding();
                  clSetq(*location,
                         clFuncallFunction(clSymbolFunctionValue(clSLOT_DEFINITION_LOCATION),
                                           slot,
                                           clEOA));
                  if (clTrue(readerp))
                    clSetq(L_g481,
                           (clTrue(clConsp(*location, clEOA)) ?
                            clMakeClosure(1,
                                          clComputeMethodFunction_Lambda,
                                          &clEnvHook(clComputeMethodFunction_Lambda),
                                          &*location) :
                            clMakeClosure(1,
                                          clComputeMethodFunction_Lambda_r1,
                                          &clEnvHook(clComputeMethodFunction_Lambda_r1),
                                          &*location)));
                  else
                    { clObject L_test__R3;
                      { clObject L_0;
                        clSetq(L_0, *location);
                        clSetq(L_test__R3, clConsp(L_0, clEOA)); }
                      clSetq(L_g481,
                             (clTrue(L_test__R3) ?
                              clMakeClosure(1,
                                            clComputeMethodFunction_Lambda_r2,
                                            &clEnvHook(clComputeMethodFunction_Lambda_r2),
                                            &*location) :
                              clMakeClosure(1,
                                            clComputeMethodFunction_Lambda_r3,
                                            &clEnvHook(clComputeMethodFunction_Lambda_r3),
                                            &*location))); } }
              else clSetq(L_g481, clNIL); } }
        else clSetq(L_g481, clNIL); }
      if (clTrue(L_g481))
        return(clValues1(L_g481));
      else
        { clObject L_0;
          clSetq(L_0, method);
          return(clFuncallFunction(clSymbolFunctionValue(clMETHOD_FUNCTION),
                                   L_0,
                                   clEOA)); } } } }

clDeclareEnv(clComputeStandardEffectiveMethodFunction_Lambda);
static clObject clComputeStandardEffectiveMethodFunction_Lambda clVdecl(_ap)
{ clUseEnv(clComputeStandardEffectiveMethodFunction_Lambda);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject L_sublist524, before;
      clSetq(L_sublist524, clEnv(0, *befores));
      clSetq(before, clCar(L_sublist524, clEOA));
      clLabel(l_ITERATE525);
      if (clTrue(clEndp(L_sublist524, clEOA))) clLocalReturn(NIL);
      { clObject L_0;
        clSetq(L_0,
               clFuncallFunction(clSymbolFunctionValue(clMETHOD_FUNCTION),
                                 before,
                                 clEOA));
        clFuncallFunction(L_0, args, clNIL, clEOA); }
      { clObject L_0;
        clSetq(L_0, L_sublist524);
        clSetq(L_sublist524, clCdr(L_0, clEOA)); }
      { clObject L_0;
        clSetq(L_0, L_sublist524);
        clSetq(before, clCar(L_0, clEOA)); }
      goto l_ITERATE525; }
    clBlockEnd(NIL);
    { clMultipleValueProg1(MVP1);
      clFuncallFunction(clEnv(1, *first_primary_function),
                        args,
                        clEnv(2, *other_primaries),
                        clEOA);
      clSaveValues(MVP1);
      { clObject L_sublist530, after;
        clSetq(L_sublist530, clEnv(3, *afters));
        clSetq(after, clCar(L_sublist530, clEOA));
        clLabel(l_ITERATE531);
        if (clTrue(clEndp(L_sublist530, clEOA)))
          clLocalReturn(NIL__r1);
        { clObject L_0;
          clSetq(L_0,
                 clFuncallFunction(clSymbolFunctionValue(clMETHOD_FUNCTION),
                                   after,
                                   clEOA));
          clFuncallFunction(L_0, args, clNIL, clEOA); }
        { clObject L_0;
          clSetq(L_0, L_sublist530);
          clSetq(L_sublist530, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_sublist530);
          clSetq(after, clCar(L_0, clEOA)); }
        goto l_ITERATE531; }
      clBlockEnd(NIL__r1);
      clRestoreValues(MVP1);
      return(clSavedValue(MVP1)); } } }

clDeclareEnv(clComputeStandardEffectiveMethodFunction_Lambda_r1);
static clObject clComputeStandardEffectiveMethodFunction_Lambda_r1 clVdecl(_ap)
{ clUseEnv(clComputeStandardEffectiveMethodFunction_Lambda_r1);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clMultipleValueProg1(MVP1);
      { clObject L_2, L_0;
        clSetq(L_0, clEnv(0, *first_primary_function));
        clSetq(L_2, clEnv(1, *other_primaries));
        clFuncallFunction(L_0, args, L_2, clEOA); }
      clSaveValues(MVP1);
      { clObject L_sublist538, after;
        clSetq(L_sublist538, clEnv(2, *afters));
        clSetq(after, clCar(L_sublist538, clEOA));
        clLabel(l_ITERATE539);
        if (clTrue(clEndp(L_sublist538, clEOA))) clLocalReturn(NIL);
        { clObject L_0;
          clSetq(L_0,
                 clFuncallFunction(clSymbolFunctionValue(clMETHOD_FUNCTION),
                                   after,
                                   clEOA));
          clFuncallFunction(L_0, args, clNIL, clEOA); }
        { clObject L_0;
          clSetq(L_0, L_sublist538);
          clSetq(L_sublist538, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_sublist538);
          clSetq(after, clCar(L_0, clEOA)); }
        goto l_ITERATE539; }
      clBlockEnd(NIL);
      clRestoreValues(MVP1);
      return(clSavedValue(MVP1)); } } }

clDeclareEnv(clComputeStandardEffectiveMethodFunction_Lambda_r2);
static clObject clComputeStandardEffectiveMethodFunction_Lambda_r2 clVdecl(_ap)
{ clUseEnv(clComputeStandardEffectiveMethodFunction_Lambda_r2);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject L_sublist544, before;
      clSetq(L_sublist544, clEnv(0, *befores));
      clSetq(before, clCar(L_sublist544, clEOA));
      clLabel(l_ITERATE545);
      if (clTrue(clEndp(L_sublist544, clEOA))) clLocalReturn(NIL);
      { clObject L_0;
        clSetq(L_0,
               clFuncallFunction(clSymbolFunctionValue(clMETHOD_FUNCTION),
                                 before,
                                 clEOA));
        clFuncallFunction(L_0, args, clNIL, clEOA); }
      { clObject L_0;
        clSetq(L_0, L_sublist544);
        clSetq(L_sublist544, clCdr(L_0, clEOA)); }
      { clObject L_0;
        clSetq(L_0, L_sublist544);
        clSetq(before, clCar(L_0, clEOA)); }
      goto l_ITERATE545; }
    clBlockEnd(NIL);
    { clObject L_2, L_0;
      clSetq(L_0, clEnv(1, *first_primary_function));
      clSetq(L_2, clEnv(2, *other_primaries));
      return(clFuncallFunction(L_0, args, L_2, clEOA)); } } }

clDeclareEnv(clComputeStandardEffectiveMethodFunction_Lambda_r3);
static clObject clComputeStandardEffectiveMethodFunction_Lambda_r3 clVdecl(_ap)
{ clUseEnv(clComputeStandardEffectiveMethodFunction_Lambda_r3);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject L_2, L_0;
      clSetq(L_0, clEnv(0, *first_primary_function));
      clSetq(L_2, clEnv(1, *other_primaries));
      return(clFuncallFunction(L_0, args, L_2, clEOA)); } } }

clDeclareEnv(clComputeStandardEffectiveMethodFunction_Lambda_r4);
static clObject clComputeStandardEffectiveMethodFunction_Lambda_r4 clVdecl(_ap)
{ clUseEnv(clComputeStandardEffectiveMethodFunction_Lambda_r4);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject L_1, L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, clEnv(0, *n));
        clSetq(L_0, clNthcdr(L_0__R1, args, clEOA)); }
      clSetq(L_1, clEnv(1, *keys));
      clCheckKeys(L_0, L_1, clEOA); }
    { clObject L_sublist558, before;
      clSetq(L_sublist558, clEnv(2, *befores));
      clSetq(before, clCar(L_sublist558, clEOA));
      clLabel(l_ITERATE559);
      if (clTrue(clEndp(L_sublist558, clEOA))) clLocalReturn(NIL);
      { clObject L_0;
        clSetq(L_0,
               clFuncallFunction(clSymbolFunctionValue(clMETHOD_FUNCTION),
                                 before,
                                 clEOA));
        clFuncallFunction(L_0, args, clNIL, clEOA); }
      { clObject L_0;
        clSetq(L_0, L_sublist558);
        clSetq(L_sublist558, clCdr(L_0, clEOA)); }
      { clObject L_0;
        clSetq(L_0, L_sublist558);
        clSetq(before, clCar(L_0, clEOA)); }
      goto l_ITERATE559; }
    clBlockEnd(NIL);
    { clMultipleValueProg1(MVP1);
      { clObject L_2, L_0;
        clSetq(L_0, clEnv(3, *first_primary_function));
        clSetq(L_2, clEnv(4, *other_primaries));
        clFuncallFunction(L_0, args, L_2, clEOA); }
      clSaveValues(MVP1);
      { clObject L_sublist564, after;
        clSetq(L_sublist564, clEnv(5, *afters));
        clSetq(after, clCar(L_sublist564, clEOA));
        clLabel(l_ITERATE565);
        if (clTrue(clEndp(L_sublist564, clEOA)))
          clLocalReturn(NIL__r1);
        { clObject L_0;
          clSetq(L_0,
                 clFuncallFunction(clSymbolFunctionValue(clMETHOD_FUNCTION),
                                   after,
                                   clEOA));
          clFuncallFunction(L_0, args, clNIL, clEOA); }
        { clObject L_0;
          clSetq(L_0, L_sublist564);
          clSetq(L_sublist564, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_sublist564);
          clSetq(after, clCar(L_0, clEOA)); }
        goto l_ITERATE565; }
      clBlockEnd(NIL__r1);
      clRestoreValues(MVP1);
      return(clSavedValue(MVP1)); } } }

clDeclareEnv(clComputeStandardEffectiveMethodFunction_Lambda_r5);
static clObject clComputeStandardEffectiveMethodFunction_Lambda_r5 clVdecl(_ap)
{ clUseEnv(clComputeStandardEffectiveMethodFunction_Lambda_r5);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject L_1, L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, clEnv(0, *n));
        clSetq(L_0, clNthcdr(L_0__R1, args, clEOA)); }
      clSetq(L_1, clEnv(1, *keys));
      clCheckKeys(L_0, L_1, clEOA); }
    { clMultipleValueProg1(MVP1);
      { clObject L_2, L_0;
        clSetq(L_0, clEnv(2, *first_primary_function));
        clSetq(L_2, clEnv(3, *other_primaries));
        clFuncallFunction(L_0, args, L_2, clEOA); }
      clSaveValues(MVP1);
      { clObject L_sublist574, after;
        clSetq(L_sublist574, clEnv(4, *afters));
        clSetq(after, clCar(L_sublist574, clEOA));
        clLabel(l_ITERATE575);
        if (clTrue(clEndp(L_sublist574, clEOA))) clLocalReturn(NIL);
        { clObject L_0;
          clSetq(L_0,
                 clFuncallFunction(clSymbolFunctionValue(clMETHOD_FUNCTION),
                                   after,
                                   clEOA));
          clFuncallFunction(L_0, args, clNIL, clEOA); }
        { clObject L_0;
          clSetq(L_0, L_sublist574);
          clSetq(L_sublist574, clCdr(L_0, clEOA)); }
        { clObject L_0;
          clSetq(L_0, L_sublist574);
          clSetq(after, clCar(L_0, clEOA)); }
        goto l_ITERATE575; }
      clBlockEnd(NIL);
      clRestoreValues(MVP1);
      return(clSavedValue(MVP1)); } } }

clDeclareEnv(clComputeStandardEffectiveMethodFunction_Lambda_r6);
static clObject clComputeStandardEffectiveMethodFunction_Lambda_r6 clVdecl(_ap)
{ clUseEnv(clComputeStandardEffectiveMethodFunction_Lambda_r6);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject L_1, L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, clEnv(0, *n));
        clSetq(L_0, clNthcdr(L_0__R1, args, clEOA)); }
      clSetq(L_1, clEnv(1, *keys));
      clCheckKeys(L_0, L_1, clEOA); }
    { clObject L_sublist582, before;
      clSetq(L_sublist582, clEnv(2, *befores));
      clSetq(before, clCar(L_sublist582, clEOA));
      clLabel(l_ITERATE583);
      if (clTrue(clEndp(L_sublist582, clEOA))) clLocalReturn(NIL);
      { clObject L_0;
        clSetq(L_0,
               clFuncallFunction(clSymbolFunctionValue(clMETHOD_FUNCTION),
                                 before,
                                 clEOA));
        clFuncallFunction(L_0, args, clNIL, clEOA); }
      { clObject L_0;
        clSetq(L_0, L_sublist582);
        clSetq(L_sublist582, clCdr(L_0, clEOA)); }
      { clObject L_0;
        clSetq(L_0, L_sublist582);
        clSetq(before, clCar(L_0, clEOA)); }
      goto l_ITERATE583; }
    clBlockEnd(NIL);
    { clObject L_2, L_0;
      clSetq(L_0, clEnv(3, *first_primary_function));
      clSetq(L_2, clEnv(4, *other_primaries));
      return(clFuncallFunction(L_0, args, L_2, clEOA)); } } }

clDeclareEnv(clComputeStandardEffectiveMethodFunction_Lambda_r7);
static clObject clComputeStandardEffectiveMethodFunction_Lambda_r7 clVdecl(_ap)
{ clUseEnv(clComputeStandardEffectiveMethodFunction_Lambda_r7);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject L_1, L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, clEnv(0, *n));
        clSetq(L_0, clNthcdr(L_0__R1, args, clEOA)); }
      clSetq(L_1, clEnv(1, *keys));
      clCheckKeys(L_0, L_1, clEOA); }
    { clObject L_2, L_0;
      clSetq(L_0, clEnv(2, *first_primary_function));
      clSetq(L_2, clEnv(3, *other_primaries));
      return(clFuncallFunction(L_0, args, L_2, clEOA)); } } }

clDeclareEnv(clComputeStandardEffectiveMethodFunction_Lambda_r8);
static clObject clComputeStandardEffectiveMethodFunction_Lambda_r8 clVdecl(_ap)
{ clUseEnv(clComputeStandardEffectiveMethodFunction_Lambda_r8);
  { clObject args, ignore;
    { clBeginParse(_ap);
      clSetq(args,
             (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
      clSetq(ignore, clVargs(_ap));
      clEndParse(_ap); }
    { clObject L_1, L_0;
      clSetq(L_0, clEnv(0, *main));
      clSetq(L_1, args);
      return(clApplyFunction(L_0, L_1, clEOA)); } } }

clDeclareEnv(clComputeStandardEffectiveMethodFunction_Lambda_r9);
static clObject clComputeStandardEffectiveMethodFunction_Lambda_r9 clVdecl(_ap)
{ clUseEnv(clComputeStandardEffectiveMethodFunction_Lambda_r9);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject L_1, L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, clEnv(0, *n));
        clSetq(L_0, clNthcdr(L_0__R1, args, clEOA)); }
      clSetq(L_1, clEnv(1, *keys));
      clCheckKeys(L_0, L_1, clEOA); }
    return(clFuncallFunction(clEnv(2, *first_around_function),
                             args,
                             clEnv(3, *other_arounds),
                             clEOA)); } }

clDeclareEnv(clComputeStandardEffectiveMethodFunction_Lambda_r10);
static clObject clComputeStandardEffectiveMethodFunction_Lambda_r10 clVdecl(_ap)
{ clUseEnv(clComputeStandardEffectiveMethodFunction_Lambda_r10);
  { clObject args;
    { clBeginParse(_ap); clSetq(args, clVargs(_ap)); clEndParse(_ap); }
    { clObject L_2, L_0;
      clSetq(L_0, clEnv(0, *first_around_function));
      clSetq(L_2, clEnv(1, *other_arounds));
      return(clFuncallFunction(L_0, args, L_2, clEOA)); } } }

clObject clComputeStandardEffectiveMethodFunction clVdecl(_ap)
{ clObject gf, methods, argument_classes;
  { clBeginParse(_ap);
    clSetq(gf, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(methods,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(argument_classes,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject *keys = clMakeBinding(), check_keys_p, arounds, primaries,
    *befores = clMakeBinding(), *afters = clMakeBinding();
    { clObject L_0;
      clSetq(L_0, gf);
      clSetq(*keys,
             clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_KEYWORDS),
                               L_0,
                               clEOA)); }
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, gf);
        clSetq(L_0,
               clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_ALLOW_OTHER_KEYS_P),
                                 L_0__R1,
                                 clEOA)); }
      clSetq(check_keys_p, clNot(L_0, clEOA)); }
    clSetq(arounds, clNIL);
    clSetq(primaries, clNIL);
    clSetq(*befores, clNIL);
    clSetq(*afters, clNIL);
    { clObject method, L_g21;
      clSetq(method, clNIL);
      clSetq(L_g21, methods);
      { clObject qualifier;
        clSetq(qualifier, clNIL);
        clLabel(NEXT_LOOP);
        if (clTrue(clEndp(L_g21, clEOA))) goto END_LOOP;
        clSetq(method, clCar(L_g21, clEOA));
        { clObject L_0;
          clSetq(L_0, L_g21);
          clSetq(L_g21, clCdr(L_0, clEOA)); }
        if (clTrue(check_keys_p))
          { clObject L_values511, method_keys, allow_other_keys_p;
            { clMultipleValueCall(MVC);
              clSetq(MVC, clSymbolFunctionValue(clLIST));
              { clObject L_0;
                clSetq(L_0, method);
                clFuncallFunction(clSymbolFunctionValue(clFUNCTION_KEYWORDS),
                                  L_0,
                                  clEOA); }
              clAccumulateValues(MVC);
              clSetq(L_values511, clMultipleValueFuncall(MVC)); }
            clSetq(method_keys, clCar(L_values511, clEOA));
            { clObject L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, L_values511);
                clSetq(L_0,
                       clSetq(L_values511, clCdr(L_0__R1, clEOA))); }
              clSetq(allow_other_keys_p, clCar(L_0, clEOA)); }
            if (clTrue(allow_other_keys_p))
              clSetq(check_keys_p, clNIL);
            else
              { clObject L_0;
                clSetq(L_0, *keys);
                clSetq(*keys, clUnion(L_0, method_keys, clEOA)); } }
        { clObject L_key512;
          { clObject L_test;
            { clObject L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, method);
                clSetq(L_0,
                       clSetq(qualifier,
                              clFuncallFunction(clSymbolFunctionValue(clMETHOD_QUALIFIERS),
                                                L_0__R1,
                                                clEOA))); }
              clSetq(L_test, clRest(L_0, clEOA)); }
            if (clTrue(L_test))
              clSetq(L_key512, qualifier);
            else
              { clObject L_0;
                clSetq(L_0, qualifier);
                clSetq(L_key512, clCar(L_0, clEOA)); } }
          { clObject L_test;
            { clObject L_0;
              clSetq(L_0, L_key512);
              clSetq(L_test, clEq(L_0, clNIL, clEOA)); }
            if (clTrue(L_test))
              { clObject L_1, L_0;
                clSetq(L_0, method);
                clSetq(L_1, primaries);
                clSetq(primaries, clCons(L_0, L_1, clEOA)); }
            else
              { clObject L_test__R1;
                { clObject L_0;
                  clSetq(L_0, L_key512);
                  clSetq(L_test__R1, clEq(L_0, keyAROUND, clEOA)); }
                if (clTrue(L_test__R1))
                  { clObject L_1, L_0;
                    clSetq(L_0, method);
                    clSetq(L_1, arounds);
                    clSetq(arounds, clCons(L_0, L_1, clEOA)); }
                else
                  { clObject L_test__R2;
                    { clObject L_0;
                      clSetq(L_0, L_key512);
                      clSetq(L_test__R2,
                             clEq(L_0, keyBEFORE, clEOA)); }
                    if (clTrue(L_test__R2))
                      { clObject L_1, L_0;
                        clSetq(L_0, method);
                        clSetq(L_1, *befores);
                        clSetq(*befores, clCons(L_0, L_1, clEOA)); }
                    else
                      { clObject L_test__R3;
                        { clObject L_0;
                          clSetq(L_0, L_key512);
                          clSetq(L_test__R3,
                                 clEq(L_0, keyAFTER, clEOA)); }
                        if (clTrue(L_test__R3))
                        { clObject L_1, L_0;
                          clSetq(L_0, method);
                          clSetq(L_1, *afters);
                          clSetq(*afters, clCons(L_0, L_1, clEOA)); }
                        else
                        { clObject STARgeneric_functionSTAR,
                          STARmethod_combinationSTAR;
                          clSetq(STARgeneric_functionSTAR, gf);
                          { clObject L_0;
                            clSetq(L_0, gf);
                            clSetq(STARmethod_combinationSTAR,
                                   clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_METHOD_COMBINATION),
                                                     L_0,
                                                     clEOA)); }
                          clDbind(clstarMETHOD_COMBINATIONstar);
                          clSetSymbolValueValue(clstarMETHOD_COMBINATIONstar,
                                                STARmethod_combinationSTAR);
                          clDbind(clstarGENERIC_FUNCTIONstar);
                          clSetSymbolValueValue(clstarGENERIC_FUNCTIONstar,
                                                STARgeneric_functionSTAR);
                          { clObject L_2, L_0;
                            clSetq(L_0, method);
                            clSetq(L_2, qualifier);
                            clInvalidMethodError(L_0,
                                                 STRn_12,
                                                 L_2,
                                                 clEOA); }
                          clUnwind(2); } } } } } }
        goto NEXT_LOOP;
        clLabel(END_LOOP); } }
    { clObject L_test;
      { clObject L_0;
        clSetq(L_0, primaries);
        clSetq(L_test, clNot(L_0, clEOA)); }
      if (clTrue(L_test))
        { clObject STARgeneric_functionSTAR,
          STARmethod_combinationSTAR;
          clSetq(STARgeneric_functionSTAR, gf);
          { clObject L_0;
            clSetq(L_0, gf);
            clSetq(STARmethod_combinationSTAR,
                   clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_METHOD_COMBINATION),
                                     L_0,
                                     clEOA)); }
          clDbind(clstarMETHOD_COMBINATIONstar);
          clSetSymbolValueValue(clstarMETHOD_COMBINATIONstar,
                                STARmethod_combinationSTAR);
          clDbind(clstarGENERIC_FUNCTIONstar);
          clSetSymbolValueValue(clstarGENERIC_FUNCTIONstar,
                                STARgeneric_functionSTAR);
          { clObject L_1;
            clSetq(L_1, argument_classes);
            clMethodCombinationError(STRn_13, L_1, clEOA); }
          clUnwind(2); } }
    { clObject L_0;
      clSetq(L_0, primaries);
      clSetq(primaries, clNreverseList(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, *befores);
      clSetq(*befores, clNreverseList(L_0, clEOA)); }
    { clObject first_primary,
      *first_primary_function = clMakeBinding(),
      *other_primaries = clMakeBinding();
      { clObject L_0;
        clSetq(L_0, primaries);
        clSetq(first_primary, clCar(L_0, clEOA)); }
      { clObject L_1;
        clSetq(L_1, argument_classes);
        clSetq(*first_primary_function,
               clComputeMethodFunction(first_primary, L_1, clEOA)); }
      { clObject L_0;
        clSetq(L_0, primaries);
        clSetq(*other_primaries, clRest(L_0, clEOA)); }
      { clObject *n = clMakeBinding(), *main = clMakeBinding();
        if (clTrue(check_keys_p))
          { clObject L_0;
            clSetq(L_0, gf);
            clSetq(*n,
                   clGenericFunctionAMPERSANDRestIndex(L_0, clEOA)); }
        else clSetq(*n, clNIL);
        { clObject L_test;
          { clObject L_g519;
            clSetq(L_g519, arounds);
            if (clTrue(L_g519))
              clSetq(L_test, L_g519);
            else
              { clObject L_0;
                clSetq(L_0, check_keys_p);
                clSetq(L_test, clNull(L_0, clEOA)); } }
          clSetq(*main,
                 (clTrue(L_test) ?
                  (clTrue(*afters) ?
                   (clTrue(*befores) ?
                    clMakeClosure(4,
                                  clComputeStandardEffectiveMethodFunction_Lambda,
                                  &clEnvHook(clComputeStandardEffectiveMethodFunction_Lambda),
                                  &*befores,
                                  &*first_primary_function,
                                  &*other_primaries,
                                  &*afters) :
                    clMakeClosure(3,
                                  clComputeStandardEffectiveMethodFunction_Lambda_r1,
                                  &clEnvHook(clComputeStandardEffectiveMethodFunction_Lambda_r1),
                                  &*first_primary_function,
                                  &*other_primaries,
                                  &*afters)) :
                   (clTrue(*befores) ?
                    clMakeClosure(3,
                                  clComputeStandardEffectiveMethodFunction_Lambda_r2,
                                  &clEnvHook(clComputeStandardEffectiveMethodFunction_Lambda_r2),
                                  &*befores,
                                  &*first_primary_function,
                                  &*other_primaries) :
                    clMakeClosure(2,
                                  clComputeStandardEffectiveMethodFunction_Lambda_r3,
                                  &clEnvHook(clComputeStandardEffectiveMethodFunction_Lambda_r3),
                                  &*first_primary_function,
                                  &*other_primaries))) :
                  (clTrue(*afters) ?
                   (clTrue(*befores) ?
                    clMakeClosure(6,
                                  clComputeStandardEffectiveMethodFunction_Lambda_r4,
                                  &clEnvHook(clComputeStandardEffectiveMethodFunction_Lambda_r4),
                                  &*n,
                                  &*keys,
                                  &*befores,
                                  &*first_primary_function,
                                  &*other_primaries,
                                  &*afters) :
                    clMakeClosure(5,
                                  clComputeStandardEffectiveMethodFunction_Lambda_r5,
                                  &clEnvHook(clComputeStandardEffectiveMethodFunction_Lambda_r5),
                                  &*n,
                                  &*keys,
                                  &*first_primary_function,
                                  &*other_primaries,
                                  &*afters)) :
                   (clTrue(*befores) ?
                    clMakeClosure(5,
                                  clComputeStandardEffectiveMethodFunction_Lambda_r6,
                                  &clEnvHook(clComputeStandardEffectiveMethodFunction_Lambda_r6),
                                  &*n,
                                  &*keys,
                                  &*befores,
                                  &*first_primary_function,
                                  &*other_primaries) :
                    clMakeClosure(4,
                                  clComputeStandardEffectiveMethodFunction_Lambda_r7,
                                  &clEnvHook(clComputeStandardEffectiveMethodFunction_Lambda_r7),
                                  &*n,
                                  &*keys,
                                  &*first_primary_function,
                                  &*other_primaries))))); }
        if (clTrue(arounds))
          { clObject all_around,
            *first_around_function = clMakeBinding(),
            *other_arounds = clMakeBinding();
            if (clTrue(arounds))
              { clObject L_0;
                { clObject L_1, L_0__R1;
                  { clObject L_0__R2;
                    clSetq(L_0__R2,
                           clMakeClosure(1,
                                         clComputeStandardEffectiveMethodFunction_Lambda_r8,
                                         &clEnvHook(clComputeStandardEffectiveMethodFunction_Lambda_r8),
                                         &*main));
                    clSetq(L_0__R1,
                           clMakeInternalMethod(L_0__R2, clEOA)); }
                  clSetq(L_1, arounds);
                  clSetq(L_0, clCons(L_0__R1, L_1, clEOA)); }
                clSetq(all_around, clNreverseList(L_0, clEOA)); }
            else clSetq(all_around, clNIL);
            { clObject L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, all_around);
                clSetq(L_0, clFirst(L_0__R1, clEOA)); }
              clSetq(*first_around_function,
                     clFuncallFunction(clSymbolFunctionValue(clMETHOD_FUNCTION),
                                       L_0,
                                       clEOA)); }
            { clObject L_0;
              clSetq(L_0, all_around);
              clSetq(*other_arounds, clRest(L_0, clEOA)); }
            if (clTrue(check_keys_p))
              return(clValues1(clMakeClosure(4,
                                             clComputeStandardEffectiveMethodFunction_Lambda_r9,
                                             &clEnvHook(clComputeStandardEffectiveMethodFunction_Lambda_r9),
                                             &*n,
                                             &*keys,
                                             &*first_around_function,
                                             &*other_arounds)));
            else
              return(clValues1(clMakeClosure(2,
                                             clComputeStandardEffectiveMethodFunction_Lambda_r10,
                                             &clEnvHook(clComputeStandardEffectiveMethodFunction_Lambda_r10),
                                             &*first_around_function,
                                             &*other_arounds))); }
        else return(clValues1(*main)); } } } }

clObject clMakeEffectiveMethodLambda clVdecl(_ap)
{ clObject gf, method_combination, methods;
  { clBeginParse(_ap);
    clSetq(gf, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(method_combination,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(methods,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_values598, form, options;
    { clMultipleValueCall(MVC);
      clSetq(MVC, clSymbolFunctionValue(clLIST));
      { clObject L_2, L_1, L_0;
        clSetq(L_0, gf);
        clSetq(L_1, method_combination);
        clSetq(L_2, methods);
        clFuncallFunction(clSymbolFunctionValue(clCOMPUTE_EFFECTIVE_METHOD),
                          L_0,
                          L_1,
                          L_2,
                          clEOA); }
      clAccumulateValues(MVC);
      clSetq(L_values598, clMultipleValueFuncall(MVC)); }
    clSetq(form, clCar(L_values598, clEOA));
    { clObject L_0;
      { clObject L_0__R1;
        clSetq(L_0__R1, L_values598);
        clSetq(L_0, clSetq(L_values598, clCdr(L_0__R1, clEOA))); }
      clSetq(options, clCar(L_0, clEOA)); }
    { clObject L_values599, bindings, arg_var, key_var;
      { clMultipleValueCall(MVC__r1);
        clSetq(MVC__r1, clSymbolFunctionValue(clLIST));
        { clObject L_0;
          clSetq(L_0, gf);
          clAdjustedLambdaBindings(L_0,
                                   clRest(clFind(keyARGUMENTS,
                                                 options,
                                                 keyKEY,
                                                 clSymbolFunctionValue(clCAR),
                                                 clEOA),
                                          clEOA),
                                   clEOA); }
        clAccumulateValues(MVC__r1);
        clSetq(L_values599, clMultipleValueFuncall(MVC__r1)); }
      clSetq(bindings, clCar(L_values599, clEOA));
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, L_values599);
          clSetq(L_0, clSetq(L_values599, clCdr(L_0__R1, clEOA))); }
        clSetq(arg_var, clCar(L_0, clEOA)); }
      { clObject L_0;
        { clObject L_0__R1;
          clSetq(L_0__R1, L_values599);
          clSetq(L_0, clSetq(L_values599, clCdr(L_0__R1, clEOA))); }
        clSetq(key_var, clCar(L_0, clEOA)); }
      { clObject gf_var;
        clSetq(gf_var,
               clFind(keyGENERIC_FUNCTION,
                      options,
                      keyKEY,
                      clSymbolFunctionValue(clCAR),
                      clEOA));
        if (clTrue(gf_var))
          { clObject L_1, L_0;
            clSetq(L_0, bindings);
            { clObject L_0__R1;
              { clObject L_1__R1, L_0__R2;
                clSetq(L_0__R2, clSecond(gf_var, clEOA));
                { clObject L_1__R2;
                  clSetq(L_1__R2, gf);
                  clSetq(L_1__R1, clList(clQUOTE, L_1__R2, clEOA)); }
                clSetq(L_0__R1, clList(L_0__R2, L_1__R1, clEOA)); }
              clSetq(L_1, clList(L_0__R1, clEOA)); }
            clSetq(bindings, clNconc(L_0, L_1, clEOA)); } }
      { clObject body;
        clSetq(body,
               clList(clCallMethodMacrolet(form, arg_var, clEOA),
                      clEOA));
        { clObject L_test;
          { clObject L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, gf);
              clSetq(L_0,
                     clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_ALLOW_OTHER_KEYS_P),
                                       L_0__R1,
                                       clEOA)); }
            clSetq(L_test, clNot(L_0, clEOA)); }
          if (clTrue(L_test))
            { clObject allowed_keys;
              { clObject L_0;
                clSetq(L_0, gf);
                clSetq(allowed_keys,
                       clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_KEYWORDS),
                                         L_0,
                                         clEOA)); }
              { clObject method, L_g22;
                clSetq(method, clNIL);
                clSetq(L_g22, methods);
                clLabel(NEXT_LOOP);
                if (clTrue(clEndp(L_g22, clEOA))) goto END_LOOP;
                clSetq(method, clCar(L_g22, clEOA));
                { clObject L_0;
                  clSetq(L_0, L_g22);
                  clSetq(L_g22, clCdr(L_0, clEOA)); }
                { clObject L_values600, keys, allow_other_keys_p;
                  { clMultipleValueCall(MVC__r2);
                    clSetq(MVC__r2, clSymbolFunctionValue(clLIST));
                    { clObject L_0;
                      clSetq(L_0, method);
                      clFuncallFunction(clSymbolFunctionValue(clFUNCTION_KEYWORDS),
                                        L_0,
                                        clEOA); }
                    clAccumulateValues(MVC__r2);
                    clSetq(L_values600,
                           clMultipleValueFuncall(MVC__r2)); }
                  clSetq(keys, clCar(L_values600, clEOA));
                  { clObject L_0;
                    { clObject L_0__R1;
                      clSetq(L_0__R1, L_values600);
                      clSetq(L_0,
                             clSetq(L_values600,
                                    clCdr(L_0__R1, clEOA))); }
                    clSetq(allow_other_keys_p, clCar(L_0, clEOA)); }
                  if (clTrue(allow_other_keys_p))
                    clLocalReturn(NIL);
                  else
                    { clObject L_1;
                      clSetq(L_1, allowed_keys);
                      clSetq(allowed_keys,
                             clUnion(keys, L_1, clEOA)); } }
                goto NEXT_LOOP;
                clLabel(END_LOOP);
                { clObject L_1, L_0;
                  { clObject L_2, L_1__R1;
                    if (clTrue(key_var))
                      clSetq(L_1__R1, key_var);
                    else
                      { clObject L_1__R2;
                        { clObject L_0__R3;
                          clSetq(L_0__R3, gf);
                          clSetq(L_1__R2,
                                 clGenericFunctionAMPERSANDRestIndex(L_0__R3,
                                                                     clEOA)); }
                        clSetq(L_1__R1,
                               clList(clNTHCDR,
                                      L_1__R2,
                                      arg_var,
                                      clEOA)); }
                    { clObject L_1__R2;
                      clSetq(L_1__R2, allowed_keys);
                      clSetq(L_2, clList(clQUOTE, L_1__R2, clEOA)); }
                    clSetq(L_0,
                           clList(clCHECK_KEYS,
                                  L_1__R1,
                                  L_2,
                                  clEOA)); }
                  clSetq(L_1, body);
                  clSetq(body, clCons(L_0, L_1, clEOA)); }
                clBlockEnd(NIL); } } }
        { clObject L_3, L_2, L_1;
          clSetq(L_1, clList(clampersandREST, arg_var, clEOA));
          clSetq(L_2,
                 clList(clDECLARE,
                        clList(clDYNAMIC_EXTENT, arg_var, clEOA),
                        clEOA));
          if (clTrue(bindings))
            { clObject L_0__R1;
              { clObject L_2__R1, L_1__R1;
                clSetq(L_1__R1, bindings);
                clSetq(L_2__R1, body);
                clSetq(L_0__R1,
                       clListSTAR(clLETstar,
                                  L_1__R1,
                                  L_2__R1,
                                  clEOA)); }
              clSetq(L_3, clList(L_0__R1, clEOA)); }
          else clSetq(L_3, body);
          return(clListSTAR(clLAMBDA, L_1, L_2, L_3, clEOA)); } } } } }

clObject clAdjustedLambdaBindings clVdecl(_ap)
{ clObject gf, em_lambda;
  { clBeginParse(_ap);
    clSetq(gf, (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(em_lambda,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject args, rest;
    clSetq(args, clGensym(STR_ARGS__16, clEOA));
    clSetq(rest, clGensym(STR_REST__17, clEOA));
    if (clTrue(em_lambda))
      { clObject whole, bindings, restvar;
        { clObject L_test__R1;
          { clObject L_0;
            { clObject L_0__R1;
              clSetq(L_0__R1, em_lambda);
              clSetq(L_0, clCar(L_0__R1, clEOA)); }
            clSetq(L_test__R1, clEq(L_0, clampersandWHOLE, clEOA)); }
          if (clTrue(L_test__R1))
            { clObject L_first_val602;
              { clObject L_0;
                clSetq(L_0, em_lambda);
                clSetq(L_first_val602, clSecond(L_0, clEOA)); }
              { clObject L_0;
                clSetq(L_0, em_lambda);
                clSetq(em_lambda, clCddr(L_0, clEOA)); }
              clSetq(whole, L_first_val602); }
          else clSetq(whole, args); }
        if (clTrue(em_lambda))
          { clObject L_0;
            { clObject L_1;
              clSetq(L_1, whole);
              clSetq(L_0, clList(rest, L_1, clEOA)); }
            clSetq(bindings, clList(L_0, clEOA)); }
        else clSetq(bindings, clNIL);
        clSetq(restvar, clNIL);
        { clObject parameter, L_g23;
          clSetq(parameter, clNIL);
          clSetq(L_g23, em_lambda);
          { clObject index, cdring, max, optional_p, restp, keyp;
            clSetq(index, I_0);
            clSetq(cdring, I_0);
            { clObject L_0;
              { clObject L_0__R1;
                clSetq(L_0__R1, gf);
                clSetq(L_0,
                       clFuncallFunction(clSymbolFunctionValue(clGENERIC_FUNCTION_REQUIRED_PARAMETERS),
                                         L_0__R1,
                                         clEOA)); }
              clSetq(max, clLength(L_0, clEOA)); }
            clSetq(optional_p, clNIL);
            clSetq(restp, clNIL);
            clSetq(keyp, clNIL);
            clLabel(NEXT_LOOP);
            if (clTrue(clEndp(L_g23, clEOA))) goto END_LOOP;
            clSetq(parameter, clCar(L_g23, clEOA));
            { clObject L_0;
              clSetq(L_0, L_g23);
              clSetq(L_g23, clCdr(L_0, clEOA)); }
            { clObject L_key603;
              clSetq(L_key603, parameter);
              if (_clEq(L_key603, clampersandOPTIONAL))
                { clSetq(cdring,
                         clFuncallFunction(clSymbolFunctionValue(clSUBT),
                                           max,
                                           index,
                                           clEOA));
                  clSetq(index, max);
                  { clObject L_0;
                    clSetq(L_0, gf);
                    clSetq(max,
                           clGenericFunctionAMPERSANDRestIndex(L_0,
                                                               clEOA)); }
                  clSetq(optional_p, clT); }
              else if (_clEq(L_key603, clampersandREST))
                { { clObject L_test__R3;
                    { clObject L_0;
                      clSetq(L_0, optional_p);
                      clSetq(L_test__R3, clNot(L_0, clEOA)); }
                    if (clTrue(L_test__R3))
                      { clObject L_0;
                        clSetq(L_0, gf);
                        clSetq(max,
                               clGenericFunctionAMPERSANDRestIndex(L_0,
                                                                   clEOA)); } }
                  { clObject L_1, L_0;
                    clSetq(L_0, max);
                    clSetq(L_1, index);
                    clSetq(cdring,
                           clFuncallFunction(clSymbolFunctionValue(clSUBT),
                                             L_0,
                                             L_1,
                                             clEOA)); }
                  clSetq(restp, clT); }
              else if (_clEq(L_key603, clampersandKEY))
                { { clObject L_test__R4;
                    { clObject L_0;
                      clSetq(L_0, restp);
                      clSetq(L_test__R4, clNot(L_0, clEOA)); }
                    if (clTrue(L_test__R4))
                      { { clObject L_test__R5;
                          { clObject L_0;
                            clSetq(L_0, optional_p);
                            clSetq(L_test__R5, clNot(L_0, clEOA)); }
                          if (clTrue(L_test__R5))
                          { clObject L_0;
                            clSetq(L_0, gf);
                            clSetq(max,
                                   clGenericFunctionAMPERSANDRestIndex(L_0,
                                                                       clEOA)); } }
                        { clObject L_1, L_0;
                          clSetq(L_0, max);
                          clSetq(L_1, index);
                          clSetq(cdring,
                                 clFuncallFunction(clSymbolFunctionValue(clSUBT),
                                                   L_0,
                                                   L_1,
                                                   clEOA)); } } }
                  clSetq(keyp, clT); }
              else if (_clEq(L_key603, clampersandAUX))
                { clSetq(index, I_0);
                  clSetq(max, I_0);
                  clSetq(restp, clNIL);
                  clSetq(keyp, clNIL); }
              else
                { clObject name, sp, advancep, check, rest__R1, tmp;
                  { clObject L_0;
                    clSetq(L_0, parameter);
                    clSetq(name, clBindingformName(L_0, clEOA)); }
                  { clObject L_test__R5;
                    { clObject L_0;
                      clSetq(L_0, parameter);
                      clSetq(L_test__R5, clConsp(L_0, clEOA)); }
                    if (clTrue(L_test__R5))
                      { clObject L_0;
                        clSetq(L_0, parameter);
                        clSetq(sp, clThird(L_0, clEOA)); }
                    else clSetq(sp, clNIL); }
                  { clObject L_1, L_0;
                    clSetq(L_0, index);
                    clSetq(L_1, max);
                    clSetq(advancep,
                           clFuncallFunction(clSymbolFunctionValue(clLT),
                                             L_0,
                                             L_1,
                                             clEOA)); }
                  { clObject L_g604;
                    clSetq(L_g604, keyp);
                    if (clTrue(L_g604))
                      clSetq(check, L_g604);
                    else
                      { clObject L_g605;
                        clSetq(L_g605, restp);
                        clSetq(check,
                               (clTrue(L_g605) ?
                                L_g605 :
                                advancep)); } }
                  if (clTrue(check))
                    { clObject L_test__R6;
                      { clObject L_0;
                        clSetq(L_0, cdring);
                        clSetq(L_test__R6, clPlusp(L_0, clEOA)); }
                      if (clTrue(L_test__R6))
                      { clObject L_first_val606;
                        { clObject L_2;
                          { clObject L_1__R1;
                            clSetq(L_1__R1, cdring);
                            clSetq(L_2,
                                   clList(clNTHCDR,
                                          L_1__R1,
                                          rest,
                                          clEOA)); }
                          clSetq(L_first_val606,
                                 clList(clSETQ, rest, L_2, clEOA)); }
                        clSetq(cdring, I_0);
                        clSetq(rest__R1, L_first_val606); }
                      else
                      clSetq(rest__R1, rest); }
                  else clSetq(rest__R1, clNIL);
                  { clObject L_test__R5;
                    if (clTrue(check))
                      { clObject L_test__R7;
                        { clObject L_g607;
                          clSetq(L_g607, sp);
                          clSetq(L_test__R7,
                                 (clTrue(L_g607) ? L_g607 : keyp)); }
                        if (clTrue(L_test__R7))
                        { clObject L_0;
                          clSetq(L_0, restp);
                          clSetq(L_test__R5, clNot(L_0, clEOA)); }
                        else
                        clSetq(L_test__R5, clNIL); }
                    else clSetq(L_test__R5, clNIL);
                    if (clTrue(L_test__R5))
                      { clObject L_0;
                        { clObject L_0__R1;
                          { clObject L_g608;
                            clSetq(L_g608, sp);
                            clSetq(L_0__R1,
                                   (clTrue(L_g608) ? L_g608 : name)); }
                          clSetq(L_0, clSymbolName(L_0__R1, clEOA)); }
                        clSetq(tmp, clGensym(L_0, clEOA)); }
                    else clSetq(tmp, clNIL); }
                  if (clTrue(tmp))
                    { clObject L_1, L_0;
                      { clObject L_1__R1, L_0__R1;
                        clSetq(L_0__R1, tmp);
                        if (clTrue(keyp))
                        { clObject L_2, L_1__R2;
                          clSetq(L_1__R2,
                                 clList(clQUOTE, name, clEOA));
                          clSetq(L_2, rest__R1);
                          clSetq(L_1__R1,
                                 clList(clMEMBER,
                                        L_1__R2,
                                        L_2,
                                        clEOA)); }
                        else
                        clSetq(L_1__R1, rest__R1);
                        clSetq(L_0, clList(L_0__R1, L_1__R1, clEOA)); }
                      clSetq(L_1, bindings);
                      clSetq(bindings, clCons(L_0, L_1, clEOA)); }
                  { clObject L_1, L_0;
                    { clObject L_1__R1;
                      if (clTrue(restp))
                      { clSetq(restp, clNIL);
                        clSetq(restvar, name);
                        clSetq(L_1__R1, rest__R1); }
                      else if (clTrue(keyp))
                      { clObject L_3, L_2, L_1__R2;
                        clSetq(L_1__R2, tmp);
                        { clObject L_1__R3;
                          clSetq(L_1__R3, tmp);
                          clSetq(L_2, clList(clCAR, L_1__R3, clEOA)); }
                        { clObject L_0__R3;
                          clSetq(L_0__R3, parameter);
                          clSetq(L_3,
                                 clBindingformInitform(L_0__R3,
                                                       clEOA)); }
                        clSetq(L_1__R1,
                               clList(clIF,
                                      L_1__R2,
                                      L_2,
                                      L_3,
                                      clEOA)); }
                      else if (clTrue(check))
                      { clObject L_3, L_2, L_1__R2;
                        clSetq(L_1__R2, rest__R1);
                        { clObject L_1__R3;
                          clSetq(L_1__R3, rest__R1);
                          clSetq(L_2, clList(clPOP, L_1__R3, clEOA)); }
                        if (clTrue(optional_p))
                        { clObject L_0__R3;
                          clSetq(L_0__R3, parameter);
                          clSetq(L_3,
                                 clBindingformInitform(L_0__R3,
                                                       clEOA)); }
                        else
                        clSetq(L_3,
                               clList(clMISSING_ARGS,
                                      clList(clQUOTE, name, clEOA),
                                      clEOA));
                        clSetq(L_1__R1,
                               clList(clIF,
                                      L_1__R2,
                                      L_2,
                                      L_3,
                                      clEOA)); }
                      else
                      { clObject L_0__R2;
                        clSetq(L_0__R2, parameter);
                        clSetq(L_1__R1,
                               clBindingformInitform(L_0__R2,
                                                     clEOA)); }
                      clSetq(L_0, clList(name, L_1__R1, clEOA)); }
                    clSetq(L_1, bindings);
                    clSetq(bindings, clCons(L_0, L_1, clEOA)); }
                  if (clTrue(sp))
                    { clObject L_1, L_0;
                      { clObject L_1__R1, L_0__R1;
                        clSetq(L_0__R1, sp);
                        clSetq(L_1__R1, (clTrue(check) ? tmp : clNIL));
                        clSetq(L_0, clList(L_0__R1, L_1__R1, clEOA)); }
                      clSetq(L_1, bindings);
                      clSetq(bindings, clCons(L_0, L_1, clEOA)); }
                  if (clTrue(advancep))
                    { clObject L_0;
                      clSetq(L_0, index);
                      clSetq(index,
                             clFuncallFunction(clSymbolFunctionValue(clADD),
                                               L_0,
                                               I_1,
                                               clEOA)); } } }
            goto NEXT_LOOP;
            clLabel(END_LOOP); } }
        { clObject L_2, L_1, L_0;
          { clObject L_0__R1;
            clSetq(L_0__R1, bindings);
            clSetq(L_0, clNreverseList(L_0__R1, clEOA)); }
          clSetq(L_1, whole);
          clSetq(L_2, restvar);
          return(clValues(L_0, L_1, L_2, clEOA)); } }
    else return(clValues(clNIL, args, clNIL, clEOA)); } }

clObject clCheckInitargs1 clVdecl(_ap)
{ clObject CL_class, initargs, valid_keys, call_list;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(initargs,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(valid_keys,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_3, clEOA)));
    clSetq(call_list, clVargs(_ap));
    clEndParse(_ap); }
  { clObject L_sublist609, call;
    clSetq(L_sublist609, call_list);
    clSetq(call, clCar(L_sublist609, clEOA));
    clLabel(l_ITERATE610);
    if (clTrue(clEndp(L_sublist609, clEOA))) clLocalReturn(NIL__r1);
    { clObject L_sublist611, method;
      { clObject L_0;
        clSetq(L_0, clFdefinition(clCar(call, clEOA), clEOA));
        clSetq(L_sublist611,
               clFuncallFunction(clSymbolFunctionValue(clCOMPUTE_APPLICABLE_METHODS),
                                 L_0,
                                 clRest(call, clEOA),
                                 clEOA)); }
      clSetq(method, clCar(L_sublist611, clEOA));
      clLabel(l_ITERATE612);
      if (clTrue(clEndp(L_sublist611, clEOA))) clLocalReturn(NIL);
      { clObject L_values613, keys, allow_other_keys_p;
        { clMultipleValueCall(MVC);
          clSetq(MVC, clSymbolFunctionValue(clLIST));
          clFuncallFunction(clSymbolFunctionValue(clFUNCTION_KEYWORDS),
                            method,
                            clEOA);
          clAccumulateValues(MVC);
          clSetq(L_values613, clMultipleValueFuncall(MVC)); }
        clSetq(keys, clCar(L_values613, clEOA));
        { clObject L_0;
          { clObject L_0__R1;
            clSetq(L_0__R1, L_values613);
            clSetq(L_0, clSetq(L_values613, clCdr(L_0__R1, clEOA))); }
          clSetq(allow_other_keys_p, clCar(L_0, clEOA)); }
        if (clTrue(allow_other_keys_p)) return(clValues1(clNIL));
        { clObject L_1;
          clSetq(L_1, valid_keys);
          clSetq(valid_keys, clAppend(keys, L_1, clEOA)); } }
      { clObject L_0;
        clSetq(L_0, L_sublist611);
        clSetq(L_sublist611, clCdr(L_0, clEOA)); }
      { clObject L_0;
        clSetq(L_0, L_sublist611);
        clSetq(method, clCar(L_0, clEOA)); }
      goto l_ITERATE612; }
    clBlockEnd(NIL);
    { clObject L_0;
      clSetq(L_0, L_sublist609);
      clSetq(L_sublist609, clCdr(L_0, clEOA)); }
    { clObject L_0;
      clSetq(L_0, L_sublist609);
      clSetq(call, clCar(L_0, clEOA)); }
    goto l_ITERATE610; }
  clBlockEnd(NIL__r1);
  { clObject bad;
    { clObject L_1, L_0;
      clSetq(L_0, initargs);
      clSetq(L_1, valid_keys);
      clSetq(bad, clFindBadKey(L_0, L_1, clEOA)); }
    if (clTrue(bad))
      { clObject L_2;
        clSetq(L_2, CL_class);
        return(clKeyNotAllowed(bad,
                               STR_for_class_tildes__18,
                               L_2,
                               clEOA)); }
    else return(clValues1(clNIL)); } }

void clInitClosRun __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_1, clIntFixnum(1));
  clSetq(I_2, clIntFixnum(2));
  clSetq(STR_Cannot_tildea_tildesdot__0,
         clCharpSimpleBaseString("Cannot ~a ~s."));
  clSetq(STRn_1,
         clCharpSimpleBaseString("Cannot change class of ~s from ~s to ~s."));
  clSetq(STR_tildequestiontilde___tildewcolon_tildewdot__2,
         clCharpSimpleBaseString("~?~_ ~w: ~w."));
  clSetq(STRn_3, clCharpSimpleBaseString("Invalid method ~w:~_ ~@?"));
  clSetq(STR_INSTANCE__4, clCharpSimpleBaseString("INSTANCE"));
  clSetq(keyINSTANCE, clMakeKeyword(STR_INSTANCE__4, clEOA));
  clSetq(I_6, clIntFixnum(6));
  clSetq(I_3, clIntFixnum(3));
  clSetq(I_4, clIntFixnum(4));
  clSetq(STRn_5,
         clCharpSimpleBaseString("~s is not known by a proper name."));
  clSetq(I_0, clIntFixnum(0));
  clSetq(CONS_1, clCons(clampersandKEY, clNIL, clEOA));
  clSetq(CONS_0, clCons(clampersandREST, CONS_1, clEOA));
  clSetq(I_16, clIntFixnum(16));
  clSetq(CONS_3, clCons(clSLOT_VALUE_USING_CLASS, clNIL, clEOA));
  clSetq(CONS_2, clCons(clSETF, CONS_3, clEOA));
  clSetq(CONS_5, clCons(clSLOT_VALUE, clNIL, clEOA));
  clSetq(CONS_4, clCons(clSETF, CONS_5, clEOA));
  clSetq(STR_KEY__6, clCharpSimpleBaseString("KEY"));
  clSetq(keyKEY, clMakeKeyword(STR_KEY__6, clEOA));
  clSetq(STRn_7,
         clCharpSimpleBaseString("Invalid :argument-predence-order ~s."));
  clSetq(STR_FUNCTION__8, clCharpSimpleBaseString("FUNCTION"));
  clSetq(keyFUNCTION, clMakeKeyword(STR_FUNCTION__8, clEOA));
  clSetq(CONS_8, clCons(clD, clNIL, clEOA));
  clSetq(CONS_7, clCons(clampersandREST, CONS_8, clEOA));
  clSetq(CONS_6, clCons(clM, CONS_7, clEOA));
  clSetq(CONS_11, clCons(clOTHER_DATA, clNIL, clEOA));
  clSetq(CONS_10, clCons(clampersandREST, CONS_11, clEOA));
  clSetq(CONS_9, clCons(clARGS, CONS_10, clEOA));
  clSetq(CONS_14, clCons(clIGNORE, CONS_11, clEOA));
  clSetq(CONS_16, clCons(clDYNAMIC_EXTENT, CONS_11, clEOA));
  clSetq(CONS_15, clCons(CONS_16, clNIL, clEOA));
  clSetq(CONS_13, clCons(CONS_14, CONS_15, clEOA));
  clSetq(CONS_12, clCons(clDECLARE, CONS_13, clEOA));
  clSetq(CONS_17, clCons(clSETF, CONS_3, clEOA));
  clSetq(STR_AROUND__9, clCharpSimpleBaseString("AROUND"));
  clSetq(keyAROUND, clMakeKeyword(STR_AROUND__9, clEOA));
  clSetq(STR_BEFORE__10, clCharpSimpleBaseString("BEFORE"));
  clSetq(keyBEFORE, clMakeKeyword(STR_BEFORE__10, clEOA));
  clSetq(STR_AFTER__11, clCharpSimpleBaseString("AFTER"));
  clSetq(keyAFTER, clMakeKeyword(STR_AFTER__11, clEOA));
  clSetq(STRn_12,
         clCharpSimpleBaseString("Illegal qualifier~{ ~s~}."));
  clSetq(STRn_13,
         clCharpSimpleBaseString("No primary methods applicable to classes ~s."));
  clSetq(STR_ARGUMENTS__14, clCharpSimpleBaseString("ARGUMENTS"));
  clSetq(keyARGUMENTS, clMakeKeyword(STR_ARGUMENTS__14, clEOA));
  clSetq(STR_GENERIC_FUNCTION__15,
         clCharpSimpleBaseString("GENERIC-FUNCTION"));
  clSetq(keyGENERIC_FUNCTION,
         clMakeKeyword(STR_GENERIC_FUNCTION__15, clEOA));
  clSetq(STR_ARGS__16, clCharpSimpleBaseString("ARGS"));
  clSetq(STR_REST__17, clCharpSimpleBaseString("REST"));
  clSetq(STR_for_class_tildes__18,
         clCharpSimpleBaseString("for class ~s"));


  cl_SETF_GlobalDeclaration(clT,
                            clstarEQL_SPECIALIZER_TYPEstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarEQL_SPECIALIZER_TYPEstar, clNIL);
  (void) clstarEQL_SPECIALIZER_TYPEstar;
  clSetSymbolFunctionValue(clILLEGAL_INITIALIZATION,
                           clMakeClosure(0,
                                         clIllegalInitialization,
                                         clNULL_HOOK));
  (void) clILLEGAL_INITIALIZATION;
  clSetSymbolFunctionValue(clILLEGAL_CHANGE_CLASS,
                           clMakeClosure(0,
                                         clIllegalChangeClass,
                                         clNULL_HOOK));
  (void) clILLEGAL_CHANGE_CLASS;
  clSetSymbolFunctionValue(clCHECK_METACLASS,
                           clMakeClosure(0,
                                         clCheckMetaclass,
                                         clNULL_HOOK));
  (void) clCHECK_METACLASS;
  cl_SETF_GlobalDeclaration(clT,
                            clstarGENERIC_FUNCTIONstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarGENERIC_FUNCTIONstar, clNIL);
  (void) clstarGENERIC_FUNCTIONstar;
  cl_SETF_GlobalDeclaration(clT,
                            clstarMETHOD_COMBINATIONstar,
                            clGLOBAL_VARIABLE,
                            clSPECIAL,
                            clEOA);
  clSetSymbolValueValue(clstarMETHOD_COMBINATIONstar, clNIL);
  (void) clstarMETHOD_COMBINATIONstar;
  clSetSymbolFunctionValue(clMETHOD_COMBINATION_ERROR,
                           clMakeClosure(0,
                                         clMethodCombinationError,
                                         clNULL_HOOK));
  (void) clMETHOD_COMBINATION_ERROR;
  clSetSymbolFunctionValue(clINVALID_METHOD_ERROR,
                           clMakeClosure(0,
                                         clInvalidMethodError,
                                         clNULL_HOOK));
  (void) clINVALID_METHOD_ERROR;
  clSetSymbolFunctionValue(clLOCAL_SLOT_P,
                           clMakeClosure(0,
                                         clLocalSlotP,
                                         clNULL_HOOK));
  (void) clLOCAL_SLOT_P;
  clSetSymbolFunctionValue(clSUBCLASSP,
                           clMakeClosure(0, clSubclassp, clNULL_HOOK));
  (void) clSUBCLASSP;
  clSetSymbolFunctionValue(clCLASSP,
                           clMakeClosure(0, clClassp, clNULL_HOOK));
  (void) clCLASSP;
  clSetSymbolFunctionValue(clEQL_SPECIALIZER_P,
                           clMakeClosure(0,
                                         clEqlSpecializerP,
                                         clNULL_HOOK));
  (void) clEQL_SPECIALIZER_P;
  clSetSymbolFunctionValue(clSPECIALIZERP,
                           clMakeClosure(0,
                                         clSpecializerp,
                                         clNULL_HOOK));
  (void) clSPECIALIZERP;
  clSetSymbolFunctionValue(clSTD_METHOD_MORE_SPECIFIC_P,
                           clMakeClosure(0,
                                         clStdMethodMoreSpecificP,
                                         clNULL_HOOK));
  (void) clSTD_METHOD_MORE_SPECIFIC_P;
  clSetSymbolFunctionValue(clCHECK_SLOT_INITIALIZATION_P,
                           clMakeClosure(0,
                                         clCheckSlotInitializationP,
                                         clNULL_HOOK));
  (void) clCHECK_SLOT_INITIALIZATION_P;
  clSetSymbolFunctionValue(clINITIALIZE_SLOT_P,
                           clMakeClosure(0,
                                         clInitializeSlotP,
                                         clNULL_HOOK));
  (void) clINITIALIZE_SLOT_P;
  clSetSymbolFunctionValue(clPROPER_NAME,
                           clMakeClosure(0,
                                         clProperName,
                                         clNULL_HOOK));
  (void) clPROPER_NAME;
  clSetSymbolFunctionValue(clN_INSTANCE_SLOTS,
                           clMakeClosure(0,
                                         clNInstanceSlots,
                                         clNULL_HOOK));
  (void) clN_INSTANCE_SLOTS;
  clSetSymbolFunctionValue(clLAMBDA_ampersandREST_INDEX,
                           clMakeClosure(0,
                                         clLambdaAMPERSANDRestIndex,
                                         clNULL_HOOK));
  (void) clLAMBDA_ampersandREST_INDEX;
  clSetSymbolFunctionValue(clGENERIC_FUNCTION_ampersandREST_INDEX,
                           clMakeClosure(0,
                                         clGenericFunctionAMPERSANDRestIndex,
                                         clNULL_HOOK));
  (void) clGENERIC_FUNCTION_ampersandREST_INDEX;
  clSetSymbolFunctionValue(clEQL_SPECIALIZER_OBJECT,
                           clMakeClosure(0,
                                         clEqlSpecializerObject,
                                         clNULL_HOOK));
  (void) clEQL_SPECIALIZER_OBJECT;
  clSetSymbolFunctionValue(clSTATIC_CLASS_WRAPPER,
                           clMakeClosure(0,
                                         clStaticClassWrapper,
                                         clNULL_HOOK));
  (void) clSTATIC_CLASS_WRAPPER;
  clSetSymbolFunctionValue(clCLASS_WRAPPERS,
                           clMakeClosure(0,
                                         clClassWrappers,
                                         clNULL_HOOK));
  (void) clCLASS_WRAPPERS;
  clSetSymbolFunctionValue(clFIND_SLOT_DEFINITION,
                           clMakeClosure(0,
                                         clFindSlotDefinition,
                                         clNULL_HOOK));
  (void) clFIND_SLOT_DEFINITION;
  clSetSymbolFunctionValue(clSLOT_EXISTS_P,
                           clMakeClosure(0,
                                         clSlotExistsP,
                                         clNULL_HOOK));
  (void) clSLOT_EXISTS_P;
  clSetSymbolFunctionValue(clSLOT_BOUNDP,
                           clMakeClosure(0,
                                         clSlotBoundp,
                                         clNULL_HOOK));
  (void) clSLOT_BOUNDP;
  clSetSymbolFunctionValue(clSLOT_VALUE,
                           clMakeClosure(0, clSlotValue, clNULL_HOOK));
  (void) clSLOT_VALUE;
  clSetSymbolFunctionValue(clSLOT_MAKUNBOUND,
                           clMakeClosure(0,
                                         clSlotMakunbound,
                                         clNULL_HOOK));
  (void) clSLOT_MAKUNBOUND;
  clSetSymbolSetfFunctionValue(clSLOT_VALUE,
                               clMakeClosure(0,
                                             cl_SETF_SlotValue,
                                             clNULL_HOOK));
  (void) CONS_4;
  clSetSymbolFunctionValue(clUPDATE_INSTANCE,
                           clMakeClosure(0,
                                         clUpdateInstance,
                                         clNULL_HOOK));
  (void) clUPDATE_INSTANCE;
  clSetSymbolFunctionValue(clUPDATE_INSTANCES_IF_NEEDED,
                           clMakeClosure(0,
                                         clUpdateInstancesIfNeeded,
                                         clNULL_HOOK));
  (void) clUPDATE_INSTANCES_IF_NEEDED;
  clSetSymbolFunctionValue(clSET_GF_LAMBDA_LIST,
                           clMakeClosure(0,
                                         clSetGfLambdaList,
                                         clNULL_HOOK));
  (void) clSET_GF_LAMBDA_LIST;
  clSetSymbolFunctionValue(clFINALIZE_GENERIC_FUNCTION,
                           clMakeClosure(0,
                                         clFinalizeGenericFunction,
                                         clNULL_HOOK));
  (void) clFINALIZE_GENERIC_FUNCTION;
  { clObject L_value475;
    clSetq(L_value475, clMakeClosure(0, clApplyMethod, clNULL_HOOK));
    cl_SETF_MacroFunction(L_value475, clAPPLY_METHOD, clEOA); }
  (void) clAPPLY_METHOD;
  clSetSymbolFunctionValue(clMAKE_INTERNAL_METHOD,
                           clMakeClosure(0,
                                         clMakeInternalMethod,
                                         clNULL_HOOK));
  (void) clMAKE_INTERNAL_METHOD;
  clSetSymbolFunctionValue(clSORT_APPLICABLE_METHODS,
                           clMakeClosure(0,
                                         clSortApplicableMethods,
                                         clNULL_HOOK));
  (void) clSORT_APPLICABLE_METHODS;
  clSetSymbolFunctionValue(clCALL_METHOD_MACROLET,
                           clMakeClosure(0,
                                         clCallMethodMacrolet,
                                         clNULL_HOOK));
  (void) clCALL_METHOD_MACROLET;
  clSetSymbolFunctionValue(clMAKE_METHOD_EXPANSION,
                           clMakeClosure(0,
                                         clMakeMethodExpansion,
                                         clNULL_HOOK));
  (void) clMAKE_METHOD_EXPANSION;
  clSetSymbolFunctionValue(clCALL_METHOD_EXPANSION,
                           clMakeClosure(0,
                                         clCallMethodExpansion,
                                         clNULL_HOOK));
  (void) clCALL_METHOD_EXPANSION;
  clSetSymbolFunctionValue(clSTANDARD_DISCRIMINATING_FUNCTION,
                           clMakeClosure(0,
                                         clStandardDiscriminatingFunction,
                                         clNULL_HOOK));
  (void) clSTANDARD_DISCRIMINATING_FUNCTION;
  clSetSymbolFunctionValue(clCOMPUTE_EFFECTIVE_METHOD_FUNCTION,
                           clMakeClosure(0,
                                         clComputeEffectiveMethodFunction,
                                         clNULL_HOOK));
  (void) clCOMPUTE_EFFECTIVE_METHOD_FUNCTION;
  clSetSymbolFunctionValue(clCOMPUTE_METHOD_FUNCTION,
                           clMakeClosure(0,
                                         clComputeMethodFunction,
                                         clNULL_HOOK));
  (void) clCOMPUTE_METHOD_FUNCTION;
  clSetSymbolFunctionValue(clCOMPUTE_STANDARD_EFFECTIVE_METHOD_FUNCTION,
                           clMakeClosure(0,
                                         clComputeStandardEffectiveMethodFunction,
                                         clNULL_HOOK));
  (void) clCOMPUTE_STANDARD_EFFECTIVE_METHOD_FUNCTION;
  clSetSymbolFunctionValue(clMAKE_EFFECTIVE_METHOD_LAMBDA,
                           clMakeClosure(0,
                                         clMakeEffectiveMethodLambda,
                                         clNULL_HOOK));
  (void) clMAKE_EFFECTIVE_METHOD_LAMBDA;
  clSetSymbolFunctionValue(clADJUSTED_LAMBDA_BINDINGS,
                           clMakeClosure(0,
                                         clAdjustedLambdaBindings,
                                         clNULL_HOOK));
  (void) clADJUSTED_LAMBDA_BINDINGS;
  clSetSymbolFunctionValue(clCHECK_INITARGS_1,
                           clMakeClosure(0,
                                         clCheckInitargs1,
                                         clNULL_HOOK));
  (void) clCHECK_INITARGS_1;
  clUnwind(4); }
