/* Generated by Eclipse Common Lisp 1.1-HOSTED on cad0.
   Monday the ninth of March, 1998, 2:16:06 pm CST. */
#include <eclipse.h>

clObject clAbstractStructureClassP(clProto), clCerror(clProto),
  clCharpSimpleBaseString __P((clCharp)), clCons(clProto),
  clDerivedTypeP(clProto), clError(clProto), clExtraArgs(clProto),
  cl_SETF_FindType(clProto), clFindType(clProto),
  clMissingArgs(clProto), clNot(clProto);

extern clObject clTYPE, clCLASS_OF, clFIND_CLASS, clFIND_TYPE,
  clFUNCALLABLE_STANDARD_INSTANCE_ACCESS, clSETF,
  clSTANDARD_INSTANCE_ACCESS;

static clObject CONS_0, CONS_1, CONS_2, CONS_3, I_1, I_2,
  STR_No_class_named_tildesdot__1, STR_No_type_named_tildesdot__0,
  STRn_2, STRn_3, STRn_4, STRn_5;

clObject clClassOf clVdecl(_ap)
{ clObject object;
  { clBeginParse(_ap);
    clSetq(object,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clValues1(clObjectClass(object))); }

clObject clFindType clVdecl(_ap)
{ clObject name, errorp, environment;
  { clBeginParse(_ap);
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(errorp, (_clVp(_ap) ? clVpop(_ap) : clT));
    clSetq(environment, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_g891;
    clSetq(L_g891, clSystemProperty(name, clTYPE, clNIL));
    if (clTrue(L_g891))
      return(clValues1(L_g891));
    else if (clTrue(errorp))
      return(clError(STR_No_type_named_tildesdot__0, name, clEOA));
    else return(clValues1(clNIL)); } }

clObject cl_SETF_FindType clVdecl(_ap)
{ clObject CL_class, name, errorp, environment;
  { clBeginParse(_ap);
    clSetq(CL_class,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(name,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(errorp, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    clSetq(environment, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  return(clValues1(clSystemPropertySetter(name, clTYPE, CL_class))); }

clObject clFindClass clVdecl(_ap)
{ clObject symbol, errorp, environment;
  { clBeginParse(_ap);
    clSetq(symbol,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(errorp, (_clVp(_ap) ? clVpop(_ap) : clT));
    clSetq(environment, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject type;
    { clObject L_2;
      clSetq(L_2, environment);
      clSetq(type, clFindType(symbol, clNIL, L_2, clEOA)); }
    { clObject L_test;
      if (clTrue(type))
        { clObject L_0;
          { clObject L_g892;
            clSetq(L_g892, clDerivedTypeP(type, clEOA));
            clSetq(L_0,
                   (clTrue(L_g892) ? L_g892 :
                    clAbstractStructureClassP(type, clEOA))); }
          clSetq(L_test, clNot(L_0, clEOA)); }
      else clSetq(L_test, clNIL);
      if (clTrue(L_test))
        return(clValues1(type));
      else if (clTrue(errorp))
        return(clError(STR_No_class_named_tildesdot__1,
                       symbol,
                       clEOA));
      else return(clValues1(clNIL)); } } }

clObject cl_SETF_FindClass clVdecl(_ap)
{ clObject new_value, symbol, errorp, environment;
  { clBeginParse(_ap);
    clSetq(new_value,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(symbol,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    clSetq(errorp, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    clSetq(environment, (_clVp(_ap) ? clVpop(_ap) : clNIL));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject type;
    { clObject L_2;
      clSetq(L_2, environment);
      clSetq(type, clFindType(symbol, clNIL, L_2, clEOA)); }
    if (clTrue(type)) {
      if (clTrue(clDerivedTypeP(type, clEOA)))
        clCerror(STRn_2, STRn_3, symbol, clEOA);
      else if (clTrue(clAbstractStructureClassP(type, clEOA)))
        clCerror(STRn_4, STRn_5, symbol, clEOA); } }
  { clObject L_arg895, L_arg896;
    clSetq(L_arg895, errorp);
    clSetq(L_arg896, environment);
    return(cl_SETF_FindType(new_value,
                            symbol,
                            L_arg895,
                            L_arg896,
                            clEOA)); } }

clObject clStandardInstanceAccess clVdecl(_ap)
{ clObject instance, location;
  { clBeginParse(_ap);
    clSetq(instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(location,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, clStandardInstanceSlots(instance));
    return(clValues1(clGetSlot(L_0, clFixnumIndex(location)))); } }

clObject clFuncallableStandardInstanceAccess clVdecl(_ap)
{ clObject instance, location;
  { clBeginParse(_ap);
    clSetq(instance,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_1, clEOA)));
    clSetq(location,
           (_clVp(_ap) ? clVpop(_ap) : clMissingArgs(I_2, clEOA)));
    if (_clVp(_ap)) clExtraArgs(clVargs(_ap), clEOA);
    clEndParse(_ap); }
  { clObject L_0;
    clSetq(L_0, clStandardInstanceSlots(instance));
    return(clValues1(clGetSlot(L_0, clFixnumIndex(location)))); } }

void clInitTypesRun __P((void)) 
{ clDbind(clstarPACKAGEstar);
  clDbind(clstarREADTABLEstar);
  clDbind(clstarLOAD_TRUENAMEstar);
  clDbind(clstarLOAD_PATHNAMEstar);
  clSetq(I_1, clIntFixnum(1));
  clSetq(STR_No_type_named_tildesdot__0,
         clCharpSimpleBaseString("No type named ~s."));
  clSetq(I_2, clIntFixnum(2));
  clSetq(CONS_1, clCons(clFIND_TYPE, clNIL, clEOA));
  clSetq(CONS_0, clCons(clSETF, CONS_1, clEOA));
  clSetq(STR_No_class_named_tildesdot__1,
         clCharpSimpleBaseString("No class named ~s."));
  clSetq(STRn_2,
         clCharpSimpleBaseString("Delete derived type specifier ~s."));
  clSetq(STRn_3,
         clCharpSimpleBaseString("~s names a derived type specifier."));
  clSetq(STRn_4,
         clCharpSimpleBaseString("Delete abstract structure ~s."));
  clSetq(STRn_5,
         clCharpSimpleBaseString("~s names an abstract structure."));
  clSetq(CONS_3, clCons(clFIND_CLASS, clNIL, clEOA));
  clSetq(CONS_2, clCons(clSETF, CONS_3, clEOA));

  clSetSymbolFunctionValue(clCLASS_OF,
                           clMakeClosure(0, clClassOf, clNULL_HOOK));
  (void) clCLASS_OF;
  clSetSymbolFunctionValue(clFIND_TYPE,
                           clMakeClosure(0, clFindType, clNULL_HOOK));
  (void) clFIND_TYPE;
  clSetSymbolSetfFunctionValue(clFIND_TYPE,
                               clMakeClosure(0,
                                             cl_SETF_FindType,
                                             clNULL_HOOK));
  (void) CONS_0;
  clSetSymbolFunctionValue(clFIND_CLASS,
                           clMakeClosure(0, clFindClass, clNULL_HOOK));
  (void) clFIND_CLASS;
  clSetSymbolSetfFunctionValue(clFIND_CLASS,
                               clMakeClosure(0,
                                             cl_SETF_FindClass,
                                             clNULL_HOOK));
  (void) CONS_2;
  clSetSymbolFunctionValue(clSTANDARD_INSTANCE_ACCESS,
                           clMakeClosure(0,
                                         clStandardInstanceAccess,
                                         clNULL_HOOK));
  (void) clSTANDARD_INSTANCE_ACCESS;
  clSetSymbolFunctionValue(clFUNCALLABLE_STANDARD_INSTANCE_ACCESS,
                           clMakeClosure(0,
                                         clFuncallableStandardInstanceAccess,
                                         clNULL_HOOK));
  (void) clFUNCALLABLE_STANDARD_INSTANCE_ACCESS;
  clUnwind(4); }
